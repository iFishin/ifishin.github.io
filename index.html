<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>墨池游鱼</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;400;500&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Noto Serif SC', serif;
            background-color: #f0fdf4;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .paper-texture {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.04;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
            pointer-events: none;
            z-index: 1;
        }
        
        .ink-wash {
            position: absolute;
            border-radius: 50%;
            filter: blur(100px);
            opacity: 0.08;
            pointer-events: none;
        }
        
        .glass-tank {
            position: relative;
            width: 50vw;
            height: 60vh;
            min-width: 600px;
            min-height: 500px;
            z-index: 10;
        }
        
        .glass-base {
            position: absolute;
            inset: 0;
            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(30px) saturate(180%);
            -webkit-backdrop-filter: blur(30px) saturate(180%);
            border-radius: 40px;
            border: 1px solid rgba(255, 255, 255, 0.6);
            box-shadow: 
                0 40px 80px -20px rgba(0, 0, 0, 0.15),
                inset 0 0 0 1px rgba(255, 255, 255, 0.8),
                inset 0 0 120px rgba(255, 255, 255, 0.4);
        }
        
        .glass-reflection {
            position: absolute;
            inset: 0;
            border-radius: 40px;
            overflow: hidden;
            pointer-events: none;
        }
        
        .glass-reflection::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                45deg,
                transparent 40%,
                rgba(255, 255, 255, 0.4) 45%,
                rgba(255, 255, 255, 0.6) 50%,
                rgba(255, 255, 255, 0.4) 55%,
                transparent 60%
            );
            transform: translateX(-100%);
            animation: glassShine 8s ease-in-out infinite;
        }
        
        @keyframes glassShine {
            0%, 100% { transform: translateX(-100%) translateY(-100%); }
            50% { transform: translateX(100%) translateY(100%); }
        }
        
        .glass-rim {
            position: absolute;
            inset: 0;
            border-radius: 40px;
            box-shadow: 
                inset 0 2px 4px rgba(255, 255, 255, 0.9),
                inset 0 -2px 4px rgba(0, 0, 0, 0.05);
            pointer-events: none;
        }
        
        .water-body {
            position: absolute;
            inset: 20px;
            background: linear-gradient(to bottom, 
                rgba(147, 197, 253, 0.15) 0%, 
                rgba(147, 197, 253, 0.05) 30%,
                rgba(6, 182, 212, 0.08) 100%);
            border-radius: 30px;
            overflow: hidden;
        }
        
        .water-ripple {
            position: absolute;
            border: 2px solid rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            pointer-events: none;
            animation: waterRippleExpand 2s ease-out forwards;
        }
        
        @keyframes waterRippleExpand {
            0% { 
                width: 0; 
                height: 0; 
                opacity: 0.8;
                border-width: 3px;
            }
            100% { 
                width: 200px; 
                height: 200px; 
                opacity: 0;
                border-width: 0;
                margin-left: -100px;
                margin-top: -100px;
            }
        }
        
        .cursor-glow {
            position: absolute;
            width: 150px;
            height: 150px;
            background: radial-gradient(circle, rgba(255,255,255,0.4) 0%, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 20;
            mix-blend-mode: overlay;
        }
        
        .glass-tank:hover .cursor-glow {
            opacity: 1;
        }
        
        .cursor-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            animation: particleFade 1s ease-out forwards;
            box-shadow: 0 0 6px rgba(255, 255, 255, 0.8);
        }
        
        @keyframes particleFade {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(0) translateY(-20px); opacity: 0; }
        }
        
        .fish {
            position: absolute;
            pointer-events: none;
            z-index: 15;
            filter: drop-shadow(0 8px 16px rgba(0,0,0,0.12));
            will-change: transform;
        }
        
        .bubble {
            position: absolute;
            background: radial-gradient(circle at 25% 25%, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.3));
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
            animation: bubbleRise linear infinite;
            pointer-events: none;
        }
        
        @keyframes bubbleRise {
            0% { 
                transform: translateY(0) translateX(0); 
                opacity: 0; 
            }
            10% { opacity: 0.8; }
            50% { transform: translateY(-30vh) translateX(15px); }
            100% { 
                transform: translateY(-60vh) translateX(-5px); 
                opacity: 0; 
            }
        }
        
        .seaweed {
            position: absolute;
            bottom: 0;
            transform-origin: bottom center;
            animation: seaweedSway 6s ease-in-out infinite;
        }
        
        @keyframes seaweedSway {
            0%, 100% { transform: rotate(-5deg); }
            50% { transform: rotate(5deg); }
        }
        
        .sand {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: linear-gradient(to top, 
                rgba(217, 119, 6, 0.15) 0%, 
                rgba(217, 119, 6, 0.05) 60%,
                transparent 100%);
            border-radius: 0 0 30px 30px;
            pointer-events: none;
        }
        
        /* 食物样式 */
        .food-pellet {
            position: absolute;
            width: 10px;
            height: 10px;
            background: radial-gradient(circle at 30% 30%, #fbbf24, #d97706);
            border-radius: 50%;
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.6);
            pointer-events: none;
            z-index: 12;
        }
        
        .controls {
            position: absolute;
            bottom: -60px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 30;
        }
        
        .control-btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.8);
            border-radius: 30px;
            cursor: pointer;
            font-family: 'Noto Serif SC', serif;
            color: #475569;
            font-size: 14px;
            letter-spacing: 0.1em;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.9);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.12);
        }
        
        .title {
            position: absolute;
            top: 40px;
            left: 40px;
            writing-mode: vertical-rl;
            text-orientation: upright;
            font-size: 1.8rem;
            color: rgba(30, 41, 59, 0.6);
            letter-spacing: 0.5em;
            font-weight: 300;
            z-index: 5;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="paper-texture"></div>
    
    <div class="ink-wash w-[600px] h-[600px] bg-emerald-800 -top-32 -left-32"></div>
    <div class="ink-wash w-[500px] h-[500px] bg-blue-900 -bottom-32 -right-32"></div>
    
    <div class="title">观鱼</div>
    
    <div class="glass-tank" id="tank">
        <div class="glass-base"></div>
        <div class="glass-reflection"></div>
        <div class="glass-rim"></div>
        
        <div class="water-body">
            <div class="cursor-glow" id="cursorGlow"></div>
            
            <svg class="seaweed left-[8%] w-28 h-52 text-emerald-800/30" viewBox="0 0 100 200" style="animation-delay: 0s;">
                <path d="M50,200 Q15,140 50,90 T45,0" stroke="currentColor" stroke-width="4" fill="none" opacity="0.6"/>
                <path d="M50,200 Q85,150 50,100 T55,20" stroke="currentColor" stroke-width="3" fill="none" opacity="0.4"/>
            </svg>
            
            <svg class="seaweed left-[22%] w-20 h-40 text-teal-800/25" viewBox="0 0 100 200" style="animation-delay: -2s;">
                <path d="M50,200 Q25,140 50,80 T55,10" stroke="currentColor" stroke-width="3" fill="none" opacity="0.5"/>
            </svg>
            
            <svg class="seaweed right-[12%] w-32 h-60 text-emerald-900/35" viewBox="0 0 100 200" style="animation-delay: -4s;">
                <path d="M50,200 Q10,160 50,110 T45,0" stroke="currentColor" stroke-width="5" fill="none" opacity="0.6"/>
                <path d="M50,200 Q90,140 50,90 T55,30" stroke="currentColor" stroke-width="3" fill="none" opacity="0.4"/>
                <path d="M50,200 Q30,130 60,80 T40,40" stroke="currentColor" stroke-width="2" fill="none" opacity="0.5"/>
            </svg>
            
            <svg class="seaweed right-[30%] w-16 h-36 text-cyan-900/20" viewBox="0 0 100 200" style="animation-delay: -1s;">
                <path d="M50,200 Q30,150 50,100 T50,20" stroke="currentColor" stroke-width="3" fill="none" opacity="0.4"/>
            </svg>
            
            <div class="sand"></div>
            
            <div id="fishLayer"></div>
            <div id="foodLayer"></div>
            <div id="bubbleLayer"></div>
        </div>
        
        <div class="controls">
            <button class="control-btn" onclick="addFish()">添鱼</button>
            <button class="control-btn" onclick="feedFish()">投喂</button>
            <button class="control-btn" onclick="scatterFish()">惊扰</button>
        </div>
    </div>

    <script>
        const tank = document.getElementById('tank');
        const waterBody = tank.querySelector('.water-body');
        const fishLayer = document.getElementById('fishLayer');
        const foodLayer = document.getElementById('foodLayer');
        const bubbleLayer = document.getElementById('bubbleLayer');
        const cursorGlow = document.getElementById('cursorGlow');
        
        let fishes = [];
        let foods = [];
        let mouseX = 0, mouseY = 0;
        let isMouseInTank = false;
        let lastMouseTime = 0;
        
        const fishColors = [
            { body: '#3b82f6', tail: '#1e3a8a', name: '蓝' },
            { body: '#10b981', tail: '#064e3b', name: '翠' },
            { body: '#64748b', tail: '#0f172a', name: '墨' },
            { body: '#06b6d4', tail: '#164e63', name: '青' },
            { body: '#8b5cf6', tail: '#4c1d95', name: '紫' },
            { body: '#f59e0b', tail: '#78350f', name: '金' }
        ];
        
        class Fish {
            constructor(x, y) {
                this.x = x || (15 + Math.random() * 70);
                this.y = y || (20 + Math.random() * 60);
                
                // 初始角度限制在水平范围（避免竖直）
                this.angle = (Math.random() - 0.5) * Math.PI * 0.6; // -54度到54度
                if (Math.random() > 0.5) this.angle += Math.PI; // 一半向左
                
                this.speed = 0.8 + Math.random() * 0.6;
                this.vx = Math.cos(this.angle) * this.speed;
                this.vy = Math.sin(this.angle) * this.speed;
                
                this.targetSpeed = this.speed;
                this.targetAngle = this.angle;
                
                this.maxSpeed = 2.5;
                this.normalSpeed = 1.0;
                this.minSpeed = 0.3;
                this.acceleration = 0.05;
                this.turnRate = 0.06;
                this.friction = 0.98;
                
                this.size = 0.9 + Math.random() * 0.4;
                this.color = fishColors[Math.floor(Math.random() * fishColors.length)];
                this.state = 'cruise';
                this.stateTimer = 0;
                
                // 饥饿系统
                this.hunger = 0;
                this.targetFood = null;
                
                this.tailPhase = Math.random() * Math.PI * 2;
                this.bodyPhase = Math.random() * Math.PI * 2;
                
                this.element = this.createSVGElement();
                this.updateTransform();
            }
            
            createSVGElement() {
                const div = document.createElement('div');
                div.className = 'fish';
                div.style.width = '100px';
                div.style.height = '50px';
                
                const svgNS = "http://www.w3.org/2000/svg";
                const svg = document.createElementNS(svgNS, 'svg');
                svg.setAttribute('viewBox', '0 0 120 60');
                svg.style.overflow = 'visible';
                
                const defs = document.createElementNS(svgNS, 'defs');
                const gradId = `grad-${this.color.name}-${Math.floor(Math.random()*1000)}`;
                defs.innerHTML = `
                    <linearGradient id="${gradId}" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:${this.color.tail}" />
                        <stop offset="50%" style="stop-color:${this.color.body}" />
                        <stop offset="100%" style="stop-color:${this.color.body}" />
                    </linearGradient>
                `;
                svg.appendChild(defs);
                
                const tail = document.createElementNS(svgNS, 'path');
                tail.setAttribute('d', 'M 12,30 Q -8,12 3,30 Q -8,48 12,30');
                tail.setAttribute('fill', this.color.tail);
                tail.style.transformOrigin = '12px 30px';
                this.tailElement = tail;
                svg.appendChild(tail);
                
                const dorsal = document.createElementNS(svgNS, 'path');
                dorsal.setAttribute('d', 'M 40,16 Q 60,2 80,16');
                dorsal.setAttribute('fill', this.color.tail);
                dorsal.setAttribute('opacity', '0.7');
                svg.appendChild(dorsal);
                
                const body = document.createElementNS(svgNS, 'ellipse');
                body.setAttribute('cx', '62');
                body.setAttribute('cy', '30');
                body.setAttribute('rx', '42');
                body.setAttribute('ry', '24');
                body.setAttribute('fill', `url(#${gradId})`);
                this.bodyElement = body;
                svg.appendChild(body);
                
                const scales = document.createElementNS(svgNS, 'g');
                scales.setAttribute('opacity', '0.2');
                for(let i=0; i<4; i++) {
                    for(let j=0; j<2; j++) {
                        const path = document.createElementNS(svgNS, 'path');
                        path.setAttribute('d', `M ${40+i*10},${20+j*14} Q ${45+i*10},${27+j*14} ${40+i*10},${34+j*14}`);
                        path.setAttribute('stroke', 'white');
                        path.setAttribute('fill', 'none');
                        scales.appendChild(path);
                    }
                }
                svg.appendChild(scales);
                
                const eyeGroup = document.createElementNS(svgNS, 'g');
                const eyeWhite = document.createElementNS(svgNS, 'circle');
                eyeWhite.setAttribute('cx', '92');
                eyeWhite.setAttribute('cy', '20');
                eyeWhite.setAttribute('r', '6');
                eyeWhite.setAttribute('fill', 'white');
                
                const eyeBlack = document.createElementNS(svgNS, 'circle');
                eyeBlack.setAttribute('cx', '94');
                eyeBlack.setAttribute('cy', '20');
                eyeBlack.setAttribute('r', '3');
                eyeBlack.setAttribute('fill', '#0f172a');
                
                const eyeShine = document.createElementNS(svgNS, 'circle');
                eyeShine.setAttribute('cx', '95');
                eyeShine.setAttribute('cy', '19');
                eyeShine.setAttribute('r', '1.5');
                eyeShine.setAttribute('fill', 'white');
                
                eyeGroup.appendChild(eyeWhite);
                eyeGroup.appendChild(eyeBlack);
                eyeGroup.appendChild(eyeShine);
                svg.appendChild(eyeGroup);
                
                div.appendChild(svg);
                fishLayer.appendChild(div);
                return div;
            }
            
            update() {
                // 饥饿增长
                this.hunger += 0.0005;
                
                // 检测食物
                if (foods.length > 0 && !this.targetFood) {
                    let nearest = null;
                    let minDist = Infinity;
                    foods.forEach(food => {
                        const dx = food.x - this.x;
                        const dy = food.y - this.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < minDist && dist < 35) {
                            minDist = dist;
                            nearest = food;
                        }
                    });
                    if (nearest) {
                        this.targetFood = nearest;
                        this.state = 'chase';
                        this.stateTimer = 200;
                    }
                }
                
                // 状态机
                this.stateTimer--;
                if (this.stateTimer <= 0) {
                    if (this.targetFood) {
                        this.targetFood = null;
                    }
                    this.chooseNewBehavior();
                }
                
                // 执行状态
                switch(this.state) {
                    case 'cruise':
                        this.cruise();
                        break;
                    case 'turn':
                        this.turn();
                        break;
                    case 'pause':
                        this.pause();
                        break;
                    case 'dart':
                        this.dart();
                        break;
                    case 'chase':
                        this.chaseFood();
                        break;
                }
                
                // 物理更新
                const currentSpeed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
                
                // 平滑速度过渡
                if (Math.abs(currentSpeed - this.targetSpeed) > 0.05) {
                    const speedDiff = this.targetSpeed - currentSpeed;
                    const adjustment = Math.sign(speedDiff) * Math.min(Math.abs(speedDiff), this.acceleration);
                    
                    if (currentSpeed > 0.01) {
                        this.vx = (this.vx / currentSpeed) * (currentSpeed + adjustment);
                        this.vy = (this.vy / currentSpeed) * (currentSpeed + adjustment);
                    } else {
                        // 从静止启动
                        this.vx = Math.cos(this.targetAngle) * (currentSpeed + adjustment);
                        this.vy = Math.sin(this.targetAngle) * (currentSpeed + adjustment);
                    }
                }
                
                // 平滑转向 - 限制最大转向角度
                const currentAngle = Math.atan2(this.vy, this.vx);
                let angleDiff = this.targetAngle - currentAngle;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                
                // 限制每帧转向角度，避免瞬间掉头
                const maxTurn = this.turnRate;
                const turnAmount = Math.max(-maxTurn, Math.min(maxTurn, angleDiff));
                const newAngle = currentAngle + turnAmount;
                
                if (currentSpeed > 0.1) {
                    this.vx = Math.cos(newAngle) * currentSpeed;
                    this.vy = Math.sin(newAngle) * currentSpeed;
                }
                
                // 摩擦力
                this.vx *= this.friction;
                this.vy *= this.friction;
                
                // 边界处理 - 软边界
                const margin = 8;
                const softZone = 20;
                
                if (this.x < margin) {
                    const force = Math.min(1, (margin - this.x) / softZone);
                    this.vx += force * 0.2;
                    // 限制角度避免竖直
                    if (this.targetAngle > Math.PI/2 && this.targetAngle < Math.PI) {
                        this.targetAngle = Math.PI * 0.75;
                    } else if (this.targetAngle < -Math.PI/2 && this.targetAngle > -Math.PI) {
                        this.targetAngle = -Math.PI * 0.75;
                    }
                } else if (this.x > 92) {
                    const force = Math.min(1, (this.x - 92) / softZone);
                    this.vx -= force * 0.2;
                    if (this.targetAngle > 0 && this.targetAngle < Math.PI/2) {
                        this.targetAngle = Math.PI * 0.25;
                    } else if (this.targetAngle < 0 && this.targetAngle > -Math.PI/2) {
                        this.targetAngle = -Math.PI * 0.25;
                    }
                }
                
                if (this.y < margin) {
                    const force = Math.min(1, (margin - this.y) / softZone);
                    this.vy += force * 0.2;
                    // 向下转向
                    if (Math.abs(this.targetAngle) < Math.PI/2) {
                        this.targetAngle = this.targetAngle > 0 ? Math.PI * 0.25 : -Math.PI * 0.25;
                    }
                } else if (this.y > 88) {
                    const force = Math.min(1, (this.y - 88) / softZone);
                    this.vy -= force * 0.2;
                    // 向上转向
                    if (Math.abs(this.targetAngle) > Math.PI/2) {
                        this.targetAngle = this.targetAngle > 0 ? Math.PI * 0.75 : -Math.PI * 0.75;
                    }
                }
                
                // 硬限制
                this.x = Math.max(3, Math.min(97, this.x));
                this.y = Math.max(5, Math.min(92, this.y));
                
                // 更新位置
                this.x += this.vx * 0.15;
                this.y += this.vy * 0.15;
                
                // 动画
                this.animate(currentSpeed);
                this.updateTransform();
            }
            
            chooseNewBehavior() {
                const rand = Math.random();
                
                if (rand < 0.45) {
                    // 巡航 - 最常用
                    this.state = 'cruise';
                    this.stateTimer = 80 + Math.random() * 120;
                    this.targetSpeed = this.normalSpeed + (Math.random() - 0.5) * 0.4;
                    // 小角度调整，保持水平趋势
                    const currentDir = Math.cos(this.targetAngle) > 0 ? 1 : -1;
                    this.targetAngle = currentDir * (Math.random() * Math.PI * 0.4);
                } else if (rand < 0.7) {
                    // 转向 - 明显改变方向但保持水平
                    this.state = 'turn';
                    this.stateTimer = 40 + Math.random() * 50;
                    this.targetSpeed = this.normalSpeed * 0.8;
                    // 翻转到另一侧，但限制角度
                    const currentDir = Math.cos(this.targetAngle) > 0 ? 1 : -1;
                    this.targetAngle = -currentDir * (Math.PI * 0.3 + Math.random() * 0.3);
                } else if (rand < 0.85) {
                    // 停顿
                    this.state = 'pause';
                    this.stateTimer = 40 + Math.random() * 80;
                    this.targetSpeed = 0.1;
                } else {
                    // 冲刺 - 快速短距离
                    this.state = 'dart';
                    this.stateTimer = 25 + Math.random() * 25;
                    this.targetSpeed = this.maxSpeed * (0.7 + Math.random() * 0.3);
                    // 冲刺角度也限制
                    const currentDir = Math.cos(this.targetAngle) > 0 ? 1 : -1;
                    this.targetAngle = currentDir * (Math.random() * Math.PI * 0.5);
                }
            }
            
            cruise() {
                // 偶尔微调
                if (Math.random() < 0.03) {
                    this.targetAngle += (Math.random() - 0.5) * 0.2;
                    // 限制角度范围
                    this.targetAngle = Math.max(-Math.PI*0.6, Math.min(Math.PI*0.6, this.targetAngle));
                }
            }
            
            turn() {
                // 转向中，角度变化在update中处理
            }
            
            pause() {
                // 轻微漂浮
                this.targetAngle += Math.sin(Date.now() * 0.001) * 0.02;
            }
            
            dart() {
                if (this.stateTimer < 10) {
                    this.targetSpeed *= 0.85;
                }
            }
            
            chaseFood() {
                if (!this.targetFood || !document.body.contains(this.targetFood.element)) {
                    this.targetFood = null;
                    this.state = 'cruise';
                    return;
                }
                
                const dx = this.targetFood.x - this.x;
                const dy = this.targetFood.y - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < 5) {
                    // 吃掉
                    this.targetFood.element.remove();
                    foods = foods.filter(f => f !== this.targetFood);
                    this.targetFood = null;
                    this.hunger = 0;
                    this.size = Math.min(this.size * 1.02, 1.5);
                    this.state = 'pause';
                    this.stateTimer = 30;
                    createBubble(this.x, this.y);
                } else {
                    // 追向食物
                    const angle = Math.atan2(dy, dx);
                    this.targetAngle = angle;
                    this.targetSpeed = this.maxSpeed * 0.9;
                    
                    // 限制垂直追逐角度
                    if (Math.abs(this.targetAngle) > Math.PI * 0.6) {
                        this.targetAngle = Math.sign(this.targetAngle) * Math.PI * 0.6;
                    }
                }
            }
            
            animate(speed) {
                const baseSpeed = 0.12;
                const speedFactor = Math.min(speed * 0.12, 0.25);
                this.tailPhase += baseSpeed + speedFactor;
                
                const tailAngle = Math.sin(this.tailPhase) * (12 + speed * 6);
                this.tailElement.style.transform = `rotate(${tailAngle}deg)`;
                
                this.bodyPhase += 0.025;
                const breath = 1 + Math.sin(this.bodyPhase) * 0.02;
                this.bodyElement.style.transform = `scale(${breath})`;
            }
            
            updateTransform() {
                // 计算实际运动角度
                const velocityAngle = Math.atan2(this.vy, this.vx);
                const degrees = velocityAngle * 180 / Math.PI;
                
                // 确定朝向
                const facingRight = this.vx >= 0;
                
                this.element.style.left = this.x + '%';
                this.element.style.top = this.y + '%';
                
                // 限制旋转角度，避免竖直
                let displayAngle = degrees;
                if (facingRight) {
                    displayAngle = Math.max(-60, Math.min(60, displayAngle));
                    this.element.style.transform = `
                        translate(-50%, -50%) 
                        scale(${this.size}) 
                        rotate(${displayAngle}deg)
                    `;
                } else {
                    displayAngle = Math.max(-60, Math.min(60, displayAngle));
                    this.element.style.transform = `
                        translate(-50%, -50%) 
                        scale(${-this.size}, ${this.size}) 
                        rotate(${-displayAngle}deg)
                    `;
                }
            }
            
            scatter() {
                this.targetFood = null;
                this.state = 'dart';
                this.stateTimer = 50;
                this.targetSpeed = this.maxSpeed;
                this.targetAngle += Math.PI + (Math.random() - 0.5) * 0.5;
                // 限制惊吓后的角度
                if (Math.abs(this.targetAngle) > Math.PI * 0.6) {
                    this.targetAngle = Math.sign(this.targetAngle) * Math.PI * 0.5;
                }
            }
        }
        
        // 鼠标特效
        tank.addEventListener('mousemove', (e) => {
            const rect = waterBody.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            isMouseInTank = true;
            
            cursorGlow.style.left = mouseX + 'px';
            cursorGlow.style.top = mouseY + 'px';
            
            const now = Date.now();
            if (now - lastMouseTime > 60) {
                createParticle(mouseX, mouseY);
                lastMouseTime = now;
            }
        });
        
        tank.addEventListener('mouseleave', () => {
            isMouseInTank = false;
            cursorGlow.style.opacity = '0';
        });
        
        tank.addEventListener('mouseenter', () => {
            cursorGlow.style.opacity = '1';
        });
        
        function createParticle(x, y) {
            const particle = document.createElement('div');
            particle.className = 'cursor-particle';
            particle.style.left = x + 'px';
            particle.style.top = y + 'px';
            waterBody.appendChild(particle);
            setTimeout(() => particle.remove(), 1000);
        }
        
        tank.addEventListener('click', (e) => {
            const rect = waterBody.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const ripple = document.createElement('div');
            ripple.className = 'water-ripple';
            ripple.style.left = x + 'px';
            ripple.style.top = y + 'px';
            waterBody.appendChild(ripple);
            setTimeout(() => ripple.remove(), 2000);
        });
        
        // 投喂功能
        function feedFish() {
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const food = document.createElement('div');
                    food.className = 'food-pellet';
                    
                    // 随机位置从顶部落下
                    const startX = 15 + Math.random() * 70;
                    food.style.left = startX + '%';
                    food.style.top = '5%';
                    foodLayer.appendChild(food);
                    
                    const foodObj = {
                        x: startX,
                        y: 5,
                        element: food,
                        vy: 0.2 + Math.random() * 0.15
                    };
                    foods.push(foodObj);
                    
                    // 食物下沉动画
                    const sink = () => {
                        if (!document.body.contains(food)) return;
                        
                        foodObj.y += foodObj.vy;
                        food.style.top = foodObj.y + '%';
                        
                        // 轻微摆动
                        foodObj.x += Math.sin(foodObj.y * 0.1) * 0.1;
                        food.style.left = foodObj.x + '%';
                        
                        if (foodObj.y < 90) {
                            requestAnimationFrame(sink);
                        } else {
                            // 到底部消失
                            food.style.opacity = '0.3';
                            setTimeout(() => {
                                if (document.body.contains(food)) {
                                    food.remove();
                                    foods = foods.filter(f => f !== foodObj);
                                }
                            }, 2000);
                        }
                    };
                    requestAnimationFrame(sink);
                }, i * 100);
            }
        }
        
        function createBubble(x, y) {
            const bubble = document.createElement('div');
            bubble.className = 'bubble';
            const size = 6 + Math.random() * 10;
            bubble.style.width = size + 'px';
            bubble.style.height = size + 'px';
            bubble.style.left = (x || (10 + Math.random() * 80)) + '%';
            bubble.style.bottom = y ? (100 - y) + '%' : (5 + Math.random() * 15) + '%';
            bubble.style.animationDuration = (5 + Math.random() * 4) + 's';
            bubbleLayer.appendChild(bubble);
            
            setTimeout(() => bubble.remove(), 9000);
        }
        
        function addFish() {
            if (fishes.length < 12) {
                fishes.push(new Fish());
            }
        }
        
        function scatterFish() {
            fishes.forEach(fish => fish.scatter());
            for(let i=0; i<3; i++) {
                setTimeout(() => {
                    const ripple = document.createElement('div');
                    ripple.className = 'water-ripple';
                    ripple.style.left = (20 + Math.random() * 60) + '%';
                    ripple.style.top = (20 + Math.random() * 60) + '%';
                    waterBody.appendChild(ripple);
                    setTimeout(() => ripple.remove(), 2000);
                }, i*100);
            }
        }
        
        // 初始化
        function init() {
            for(let i=0; i<6; i++) {
                setTimeout(() => fishes.push(new Fish()), i*400);
            }
            
            setInterval(() => createBubble(), 3000);
            
            function animate() {
                fishes.forEach(fish => fish.update());
                requestAnimationFrame(animate);
            }
            requestAnimationFrame(animate);
        }
        
        init();
    </script>
</body>
</html>