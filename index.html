<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>观鱼</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;400;500;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Noto Serif SC', serif;
            background: linear-gradient(180deg, #e8f0e5 0%, #dde8d8 50%, #d4e3ce 100%);
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            width: 100vw;
            align-items: center;
            justify-content: center;
        }
        
        /* 宣纸纹理 */
        .paper-texture {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.04;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
            pointer-events: none;
            z-index: 1;
        }
        
        /* 水墨晕染背景 */
        .ink-wash {
            position: absolute;
            border-radius: 50%;
            filter: blur(100px);
            opacity: 0.08;
            pointer-events: none;
            animation: inkFloat 25s ease-in-out infinite;
        }
        
        @keyframes inkFloat {
            0%, 100% { transform: translate(0, 0) scale(1); opacity: 0.08; }
            33% { transform: translate(20px, -15px) scale(1.05); opacity: 0.1; }
            66% { transform: translate(-15px, 20px) scale(0.98); opacity: 0.06; }
        }
        
        /* 左侧柳树 */
        .willow-left {
            position: fixed;
            left: -20px;
            top: 0;
            height: 100vh;
            width: 180px;
            z-index: 2;
            pointer-events: none;
            opacity: 0.7;
        }
        
        /* 右侧柳树 */
        .willow-right {
            position: fixed;
            right: -20px;
            top: 0;
            height: 100vh;
            width: 180px;
            z-index: 2;
            pointer-events: none;
            opacity: 0.7;
            transform: scaleX(-1);
        }
        
        .willow-branch {
            transform-origin: top center;
            animation: willowSway 4s ease-in-out infinite;
        }
        
        .willow-branch:nth-child(2) { animation-delay: -0.5s; }
        .willow-branch:nth-child(3) { animation-delay: -1s; }
        .willow-branch:nth-child(4) { animation-delay: -1.5s; }
        .willow-branch:nth-child(5) { animation-delay: -2s; }
        
        @keyframes willowSway {
            0%, 100% { transform: rotate(-2deg); }
            50% { transform: rotate(2deg); }
        }
        
        /* 标题 */
        .title {
            position: absolute;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2rem;
            color: rgba(60, 80, 60, 0.7);
            letter-spacing: 0.5em;
            font-weight: 300;
            z-index: 5;
            pointer-events: none;
            text-shadow: 0 2px 20px rgba(255,255,255,0.5);
        }
        
        /* 诗句展示 */
        .poem-container {
            position: absolute;
            top: 100px;
            right: 220px;
            writing-mode: vertical-rl;
            text-orientation: upright;
            z-index: 5;
            pointer-events: none;
            opacity: 0.6;
            transition: opacity 0.5s;
        }
        
        .poem-line {
            font-size: 0.9rem;
            color: rgba(60, 80, 60, 0.65);
            letter-spacing: 0.25em;
            line-height: 2.2;
            font-weight: 300;
        }
        
        .poem-author {
            font-size: 0.7rem;
            color: rgba(60, 80, 60, 0.5);
            margin-top: 0.8em;
            letter-spacing: 0.15em;
        }
        
        /* 鱼缸 - iOS 26风格毛玻璃 */
        .glass-tank {
            position: relative;
            width: 55vw;
            height: 50vh;
            z-index: 10;
            margin: 0 auto;
        }
        
        .glass-base {
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.25) 0%, 
                rgba(255, 255, 255, 0.1) 50%,
                rgba(255, 255, 255, 0.15) 100%);
            backdrop-filter: blur(25px) saturate(150%);
            -webkit-backdrop-filter: blur(25px) saturate(150%);
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.4);
            box-shadow: 
                /* 外阴影 - 柔和的投影 */
                0 25px 50px -12px rgba(0, 0, 0, 0.15),
                0 0 0 1px rgba(255, 255, 255, 0.2),
                /* 内发光 */
                inset 0 1px 1px rgba(255, 255, 255, 0.6),
                inset 0 -1px 1px rgba(0, 0, 0, 0.05);
        }
        
        /* 玻璃边缘高光 */
        .glass-rim {
            position: absolute;
            inset: 0;
            border-radius: 24px;
            pointer-events: none;
            box-shadow: 
                inset 0 1px 2px rgba(255, 255, 255, 0.8),
                inset 0 -1px 2px rgba(0, 0, 0, 0.03);
        }
        
        /* 水面 */
        .water-body {
            position: absolute;
            inset: 12px;
            background: linear-gradient(to bottom, 
                rgba(147, 197, 253, 0.08) 0%, 
                rgba(147, 197, 253, 0.03) 40%,
                rgba(6, 182, 212, 0.05) 100%);
            border-radius: 18px;
            overflow: hidden;
        }
        
        /* 水面微光 */
        .water-surface {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: linear-gradient(to bottom, 
                rgba(255, 255, 255, 0.15) 0%, 
                transparent 100%);
            border-radius: 18px 18px 0 0;
            pointer-events: none;
        }
        
        /* 水墨涟漪 */
        .water-ripple {
            position: absolute;
            border: 1px solid rgba(80, 100, 80, 0.25);
            border-radius: 50%;
            pointer-events: none;
            animation: inkRippleExpand 2s ease-out forwards;
        }
        
        @keyframes inkRippleExpand {
            0% { 
                width: 0; 
                height: 0; 
                opacity: 0.5;
                border-width: 1.5px;
            }
            100% { 
                width: 150px; 
                height: 150px; 
                opacity: 0;
                border-width: 0;
                margin-left: -75px;
                margin-top: -75px;
            }
        }
        
        /* 鼠标光晕 */
        .cursor-glow {
            position: absolute;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, rgba(255,255,255,0.25) 0%, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 20;
            mix-blend-mode: overlay;
        }
        
        .glass-tank:hover .cursor-glow {
            opacity: 1;
        }
        
        .cursor-particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            pointer-events: none;
            animation: particleFade 1s ease-out forwards;
        }
        
        @keyframes particleFade {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(0) translateY(-12px); opacity: 0; }
        }
        
        /* 鱼 */
        .fish {
            position: absolute;
            pointer-events: none;
            z-index: 15;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.08));
            will-change: transform;
            transition: filter 0.3s ease;
        }
        
        /* 气泡 */
        .bubble {
            position: absolute;
            background: radial-gradient(circle at 25% 25%, rgba(255, 255, 255, 0.85), rgba(255, 255, 255, 0.2));
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.35);
            animation: bubbleRise linear infinite;
            pointer-events: none;
        }
        
        @keyframes bubbleRise {
            0% { 
                transform: translateY(0) translateX(0); 
                opacity: 0; 
            }
            10% { opacity: 0.6; }
            50% { transform: translateY(-20vh) translateX(10px); }
            100% { 
                transform: translateY(-45vh) translateX(-3px); 
                opacity: 0; 
            }
        }
        
        /* 水草 */
        .seaweed {
            position: absolute;
            bottom: 0;
            transform-origin: bottom center;
            animation: seaweedSway 5s ease-in-out infinite;
        }
        
        @keyframes seaweedSway {
            0%, 100% { transform: rotate(-3deg); }
            50% { transform: rotate(3deg); }
        }
        
        /* 沙底 */
        .sand {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: linear-gradient(to top, 
                rgba(180, 160, 130, 0.15) 0%, 
                rgba(180, 160, 130, 0.06) 60%,
                transparent 100%);
            border-radius: 0 0 18px 18px;
            pointer-events: none;
        }
        
        /* 食物 */
        .food-pellet {
            position: absolute;
            width: 7px;
            height: 7px;
            background: radial-gradient(circle at 30% 30%, #fbbf24, #d97706);
            border-radius: 50%;
            box-shadow: 0 0 5px rgba(251, 191, 36, 0.4);
            pointer-events: none;
            z-index: 12;
        }
        
        /* 控制按钮 */
        .controls {
            position: absolute;
            bottom: -50px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 12px;
            z-index: 30;
            width: min(92vw, 720px);
        }
        
        .control-btn {
            padding: 10px 24px;
            background: rgba(255, 255, 255, 0.55);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 20px;
            cursor: pointer;
            font-family: 'Noto Serif SC', serif;
            color: #4a5a4a;
            font-size: 13px;
            letter-spacing: 0.15em;
            transition: all 0.3s;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.8);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
        }

        .control-btn.mode {
            background: rgba(245, 246, 238, 0.8);
            border-color: rgba(95, 110, 95, 0.25);
        }
        
        /* 主题切换 */
        .theme-btn {
            position: absolute;
            top: 40px;
            right: 220px;
            z-index: 50;
            background: rgba(255,255,255,0.5);
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .theme-btn:hover {
            background: rgba(255, 255, 255, 0.8);
            transform: scale(1.05);
        }
        
        .theme-menu {
            position: absolute;
            top: 85px;
            right: 220px;
            background: rgba(255,255,255,0.95);
            border-radius: 14px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            padding: 8px 0;
            min-width: 100px;
            z-index: 100;
            display: none;
        }
        
        .theme-menu.active {
            display: block;
        }
        
        .theme-option {
            padding: 8px 18px;
            font-size: 13px;
            color: #4a5a4a;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .theme-option:hover {
            background: #e8f0e5;
        }
        
        /* ========== 水墨猫与凳子（重构） ========== */
        .cat-scene {
            position: fixed;
            right: 4.5%;
            bottom: 5.5%;
            z-index: 8;
            pointer-events: none;
        }
        
        .cat-container {
            position: relative;
            width: 330px;
            height: 235px;
            pointer-events: auto;
            cursor: pointer;
        }

        .ink-stool {
            transform-origin: 228px 198px;
            animation: stoolSway 8s ease-in-out infinite;
        }

        @keyframes stoolSway {
            0%, 100% { transform: rotate(-0.6deg); }
            50% { transform: rotate(0.6deg); }
        }

        .ink-cat {
            transform-origin: 225px 150px;
            animation: catIdle 6.8s ease-in-out infinite;
        }

        @keyframes catIdle {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            40% { transform: translateY(-1px) rotate(-0.6deg); }
            68% { transform: translateY(0.5px) rotate(0.4deg); }
        }

        .ink-cat-body {
            transform-origin: 230px 157px;
            animation: catBreathe 4.8s ease-in-out infinite;
        }
        
        @keyframes catBreathe {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.014); }
        }

        .ink-cat-head {
            transform-origin: 166px 112px;
            animation: catHeadTilt 6.2s ease-in-out infinite;
        }

        @keyframes catHeadTilt {
            0%, 100% { transform: rotate(0deg); }
            45% { transform: rotate(-1.2deg) translateX(-1px); }
            72% { transform: rotate(0.8deg); }
        }

        .ink-cat-ear-left {
            transform-origin: 146px 84px;
            animation: earTwitchLeft 9s ease-in-out infinite;
        }

        .ink-cat-ear-right {
            transform-origin: 177px 84px;
            animation: earTwitchRight 8.6s ease-in-out infinite;
        }

        @keyframes earTwitchLeft {
            0%, 93%, 100% { transform: rotate(0deg); }
            95% { transform: rotate(-5deg); }
            97% { transform: rotate(2deg); }
        }

        @keyframes earTwitchRight {
            0%, 91%, 100% { transform: rotate(0deg); }
            93% { transform: rotate(3deg); }
            96% { transform: rotate(-1.5deg); }
        }

        .ink-cat-tail {
            transform-origin: 274px 158px;
            animation: catTailWag 5.4s ease-in-out infinite;
        }
        
        @keyframes catTailWag {
            0%, 100% { transform: rotate(-7deg); }
            24% { transform: rotate(7deg); }
            52% { transform: rotate(-2deg); }
            78% { transform: rotate(9deg); }
        }

        .ink-cat-eye {
            transform-origin: center;
            animation: catBlink 6.4s ease-in-out infinite;
        }
        
        @keyframes catBlink {
            0%, 49%, 53%, 100% { transform: scaleY(1); }
            51% { transform: scaleY(0.09); }
        }

        .ink-cat-paw-front {
            transform-origin: 184px 190px;
        }

        .cat-container.active .ink-cat-head {
            animation: catPeek 0.55s ease-out;
        }

        .cat-container.active .ink-cat-paw-front {
            animation: pawTap 0.6s ease-out;
        }

        .cat-container.active .ink-cat-tail {
            animation-duration: 2.1s;
        }

        @keyframes catPeek {
            0% { transform: rotate(0deg) translateX(0); }
            45% { transform: rotate(-4deg) translateX(-3px); }
            100% { transform: rotate(0deg) translateX(0); }
        }

        @keyframes pawTap {
            0% { transform: rotate(0deg); }
            36% { transform: rotate(-18deg) translate(-3px, -1px); }
            70% { transform: rotate(-9deg); }
            100% { transform: rotate(0deg); }
        }
        
        /* 喵气泡 */
        .meow-bubble {
            position: absolute;
            top: 20px;
            right: 30px;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 16px;
            border-radius: 16px;
            font-size: 14px;
            color: #4a5a4a;
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.3s;
            pointer-events: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
        }
        
        .meow-bubble::before {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 20px;
            border-width: 8px 8px 0;
            border-style: solid;
            border-color: rgba(255, 255, 255, 0.9) transparent transparent;
        }
        
        .cat-container.active .meow-bubble {
            opacity: 1;
            transform: translateY(0);
        }
        
        /* 主题样式 */
        body.theme-sky {
            background: linear-gradient(180deg, #e0f0f5 0%, #d5e8f0 50%, #c8e0eb 100%);
        }
        
        body.theme-sky .title,
        body.theme-sky .poem-line {
            color: rgba(50, 80, 100, 0.65);
        }
        
        body.theme-sky .poem-author {
            color: rgba(50, 80, 100, 0.5);
        }
        
        body.theme-sky .control-btn {
            background: rgba(255, 255, 255, 0.6);
            color: #3a5a6a;
        }
        
        body.theme-night {
            background: linear-gradient(180deg, #1a2025 0%, #151a1f 50%, #101418 100%);
        }
        
        body.theme-night .title,
        body.theme-night .poem-line {
            color: rgba(180, 190, 180, 0.6);
        }
        
        body.theme-night .poem-author {
            color: rgba(180, 190, 180, 0.4);
        }
        
        body.theme-night .glass-base {
            background: linear-gradient(135deg, 
                rgba(40, 50, 55, 0.4) 0%, 
                rgba(30, 40, 45, 0.2) 50%,
                rgba(35, 45, 50, 0.25) 100%);
            border: 1px solid rgba(80, 90, 100, 0.3);
        }
        
        body.theme-night .control-btn {
            background: rgba(40, 50, 55, 0.6);
            color: #b0c0b0;
            border-color: rgba(80, 90, 100, 0.3);
        }
        
        /* 移动端适配 */
        @media (max-width: 1024px) {
            .glass-tank {
                width: 70vw;
                height: 55vh;
            }
            
            .cat-scene {
                right: 2%;
            }
            
            .cat-container {
                width: 220px;
                height: 160px;
            }
            
            .poem-container {
                right: 180px;
            }
            
            .theme-btn {
                right: 180px;
            }
            
            .theme-menu {
                right: 180px;
            }
        }
        
        @media (max-width: 768px) {
            html, body {
                height: 100%;
            }
            
            body {
                height: 100vh;
                padding: 0;
            }
            
            .glass-tank {
                width: 90vw;
                height: 60vh;
            }
            
            .title {
                top: 20px;
                font-size: 1.4rem;
                letter-spacing: 0.3em;
            }
            
            .poem-container,
            .theme-btn,
            .theme-menu {
                display: none;
            }
            
            .controls {
                position: fixed;
                bottom: 15px;
                left: 50%;
                transform: translateX(-50%);
                gap: 10px;
                width: 94vw;
            }
            
            .control-btn {
                padding: 8px 14px;
                font-size: 12px;
            }
            
            /* 移动端隐藏猫和柳树 */
            .cat-scene,
            .willow-left,
            .willow-right {
                display: none;
            }
        }
    </style>
<base target="_blank">
</head>
<body>
    <!-- 宣纸纹理 -->
    <div class="paper-texture"></div>
    
    <!-- 水墨晕染背景 -->
    <div class="ink-wash w-[400px] h-[400px] bg-stone-500 -top-16 -left-16" style="animation-delay: 0s;"></div>
    <div class="ink-wash w-[350px] h-[350px] bg-slate-600 -bottom-12 -right-12" style="animation-delay: -8s;"></div>
    
    <!-- 左侧柳树 -->
    <svg class="willow-left" viewBox="0 0 180 800" preserveAspectRatio="xMinYMid slice">
        <!-- 主干 -->
        <path d="M80,0 Q85,200 75,400 Q70,600 80,800" stroke="rgba(60,80,60,0.3)" stroke-width="8" fill="none"/>
        <path d="M80,0 Q82,200 78,400 Q76,600 80,800" stroke="rgba(80,100,80,0.2)" stroke-width="4" fill="none"/>
        
        <!-- 柳枝1 -->
        <g class="willow-branch">
            <path d="M82,80 Q120,150 140,280 Q150,380 130,500" stroke="rgba(70,90,70,0.25)" stroke-width="2" fill="none"/>
            <path d="M140,280 Q145,320 138,360" stroke="rgba(80,110,80,0.2)" stroke-width="1" fill="none"/>
            <path d="M130,500 Q125,550 135,600" stroke="rgba(80,110,80,0.2)" stroke-width="1" fill="none"/>
        </g>
        
        <!-- 柳枝2 -->
        <g class="willow-branch">
            <path d="M78,150 Q40,250 25,400 Q15,520 35,650" stroke="rgba(70,90,70,0.25)" stroke-width="2" fill="none"/>
            <path d="M25,400 Q20,450 28,500" stroke="rgba(80,110,80,0.2)" stroke-width="1" fill="none"/>
        </g>
        
        <!-- 柳枝3 -->
        <g class="willow-branch">
            <path d="M80,250 Q110,350 120,480 Q125,580 110,700" stroke="rgba(70,90,70,0.22)" stroke-width="1.5" fill="none"/>
        </g>
        
        <!-- 柳枝4 -->
        <g class="willow-branch">
            <path d="M76,320 Q45,420 35,550 Q30,650 45,750" stroke="rgba(70,90,70,0.22)" stroke-width="1.5" fill="none"/>
        </g>
        
        <!-- 柳叶点缀 -->
        <ellipse cx="140" cy="280" rx="8" ry="3" fill="rgba(90,120,90,0.2)" transform="rotate(30 140 280)"/>
        <ellipse cx="25" cy="400" rx="8" ry="3" fill="rgba(90,120,90,0.2)" transform="rotate(-20 25 400)"/>
        <ellipse cx="120" cy="480" rx="7" ry="2.5" fill="rgba(90,120,90,0.18)" transform="rotate(25 120 480)"/>
        <ellipse cx="35" cy="550" rx="7" ry="2.5" fill="rgba(90,120,90,0.18)" transform="rotate(-25 35 550)"/>
    </svg>
    
    <!-- 右侧柳树 -->
    <svg class="willow-right" viewBox="0 0 180 800" preserveAspectRatio="xMinYMid slice">
        <path d="M80,0 Q85,200 75,400 Q70,600 80,800" stroke="rgba(60,80,60,0.3)" stroke-width="8" fill="none"/>
        <path d="M80,0 Q82,200 78,400 Q76,600 80,800" stroke="rgba(80,100,80,0.2)" stroke-width="4" fill="none"/>
        
        <g class="willow-branch">
            <path d="M82,80 Q120,150 140,280 Q150,380 130,500" stroke="rgba(70,90,70,0.25)" stroke-width="2" fill="none"/>
            <path d="M140,280 Q145,320 138,360" stroke="rgba(80,110,80,0.2)" stroke-width="1" fill="none"/>
            <path d="M130,500 Q125,550 135,600" stroke="rgba(80,110,80,0.2)" stroke-width="1" fill="none"/>
        </g>
        
        <g class="willow-branch">
            <path d="M78,150 Q40,250 25,400 Q15,520 35,650" stroke="rgba(70,90,70,0.25)" stroke-width="2" fill="none"/>
            <path d="M25,400 Q20,450 28,500" stroke="rgba(80,110,80,0.2)" stroke-width="1" fill="none"/>
        </g>
        
        <g class="willow-branch">
            <path d="M80,250 Q110,350 120,480 Q125,580 110,700" stroke="rgba(70,90,70,0.22)" stroke-width="1.5" fill="none"/>
        </g>
        
        <g class="willow-branch">
            <path d="M76,320 Q45,420 35,550 Q30,650 45,750" stroke="rgba(70,90,70,0.22)" stroke-width="1.5" fill="none"/>
        </g>
        
        <ellipse cx="140" cy="280" rx="8" ry="3" fill="rgba(90,120,90,0.2)" transform="rotate(30 140 280)"/>
        <ellipse cx="25" cy="400" rx="8" ry="3" fill="rgba(90,120,90,0.2)" transform="rotate(-20 25 400)"/>
        <ellipse cx="120" cy="480" rx="7" ry="2.5" fill="rgba(90,120,90,0.18)" transform="rotate(25 120 480)"/>
        <ellipse cx="35" cy="550" rx="7" ry="2.5" fill="rgba(90,120,90,0.18)" transform="rotate(-25 35 550)"/>
    </svg>
    
    <!-- 标题 -->
    <div class="title">观鱼</div>
    
    <!-- 诗句展示 -->
    <div class="poem-container" id="poemContainer">
        <div class="poem-line" id="poemLine1">鱼戏莲叶间</div>
        <div class="poem-line" id="poemLine2">鱼戏莲叶东</div>
        <div class="poem-author" id="poemAuthor">—— 汉乐府</div>
    </div>
    
    <!-- 主题切换 -->
    <div class="theme-btn" id="themeBtn" title="切换主题">
        <svg width="20" height="20" fill="none" viewBox="0 0 24 24">
            <path d="M12 3v2m0 14v2m9-9h-2M5 12H3m15.364-6.364l-1.414 1.414M6.05 17.95l-1.414 1.414m12.728 0l-1.414-1.414M6.05 6.05L4.636 4.636" stroke="#4a5a4a" stroke-width="1.5" stroke-linecap="round"/>
        </svg>
    </div>
    <div class="theme-menu" id="themeMenu">
        <div class="theme-option" data-theme="">春绿</div>
        <div class="theme-option" data-theme="sky">晴空</div>
        <div class="theme-option" data-theme="night">夜色</div>
    </div>
    
    <!-- 鱼缸 -->
    <div class="glass-tank" id="tank">
        <div class="glass-base"></div>
        <div class="glass-rim"></div>
        <div class="water-body">
            <div class="water-surface"></div>
            <div class="cursor-glow" id="cursorGlow"></div>
            
            <!-- 水草 -->
            <svg class="seaweed left-[8%] w-20 h-36 text-emerald-700/25" viewBox="0 0 100 200" style="animation-delay: 0s;">
                <path d="M50,200 Q18,145 50,95 T48,5" stroke="currentColor" stroke-width="3" fill="none" opacity="0.6"/>
                <path d="M50,200 Q82,155 50,105 T52,25" stroke="currentColor" stroke-width="2" fill="none" opacity="0.4"/>
            </svg>
            <svg class="seaweed left-[22%] w-14 h-28 text-teal-700/20" viewBox="0 0 100 200" style="animation-delay: -2s;">
                <path d="M50,200 Q28,145 50,85 T52,15" stroke="currentColor" stroke-width="2" fill="none" opacity="0.5"/>
            </svg>
            <svg class="seaweed right-[10%] w-24 h-44 text-emerald-800/30" viewBox="0 0 100 200" style="animation-delay: -4s;">
                <path d="M50,200 Q12,165 50,115 T48,5" stroke="currentColor" stroke-width="4" fill="none" opacity="0.6"/>
                <path d="M50,200 Q88,145 50,95 T52,35" stroke="currentColor" stroke-width="2" fill="none" opacity="0.4"/>
            </svg>
            <svg class="seaweed right-[28%] w-12 h-28 text-cyan-800/18" viewBox="0 0 100 200" style="animation-delay: -1s;">
                <path d="M50,200 Q32,155 50,105 T50,25" stroke="currentColor" stroke-width="2" fill="none" opacity="0.4"/>
            </svg>
            
            <!-- 沙底 -->
            <div class="sand"></div>
            
            <!-- 鱼层 -->
            <div id="fishLayer"></div>
            <!-- 食物层 -->
            <div id="foodLayer"></div>
            <!-- 气泡层 -->
            <div id="bubbleLayer"></div>
        </div>
        
        <!-- 控制按钮 -->
        <div class="controls">
            <button class="control-btn" onclick="addFish()">添鱼</button>
            <button class="control-btn" onclick="feedFish()">投喂</button>
            <button class="control-btn" onclick="scatterFish()">惊扰</button>
            <button class="control-btn mode" id="swimModeBtn" onclick="cycleSwimMode()">节奏：灵动</button>
        </div>
    </div>
    
    <!-- 水墨猫 -->
    <div class="cat-scene" id="catScene">
        <div class="cat-container" id="catContainer">
            <div class="meow-bubble">喵~</div>
            <svg viewBox="0 0 330 235" width="330" height="235">
                <defs>
                    <linearGradient id="inkCatWash" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" stop-color="rgba(25,25,25,0.94)" />
                        <stop offset="100%" stop-color="rgba(10,10,10,0.98)" />
                    </linearGradient>
                    <linearGradient id="stoolWash" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" stop-color="rgba(122,102,78,0.8)" />
                        <stop offset="100%" stop-color="rgba(83,67,48,0.84)" />
                    </linearGradient>
                </defs>

                <g class="ink-stool" opacity="0.78">
                    <ellipse cx="228" cy="198" rx="72" ry="16.5" fill="url(#stoolWash)"/>
                    <rect x="173" y="198" width="13" height="35" rx="6" fill="rgba(88,70,50,0.78)"/>
                    <rect x="214" y="200" width="13" height="33" rx="6" fill="rgba(88,70,50,0.78)"/>
                    <rect x="255" y="198" width="13" height="35" rx="6" fill="rgba(88,70,50,0.78)"/>
                    <ellipse cx="228" cy="198" rx="64" ry="11.5" fill="rgba(255,255,255,0.08)"/>
                </g>

                <g class="ink-cat">
                    <path class="ink-cat-tail" d="M270,159 Q310,132 318,92 Q323,59 305,44 Q296,36 287,48 Q281,67 288,93 Q298,124 270,159"
                        fill="url(#inkCatWash)" opacity="0.96"/>

                    <g class="ink-cat-body">
                        <path d="M176,176 Q163,151 176,128 Q194,99 243,108 Q285,116 289,155 Q292,179 269,191 Q220,203 176,176 Z"
                            fill="url(#inkCatWash)"/>
                        <path d="M224,131 Q252,138 267,159" stroke="rgba(210,210,210,0.14)" stroke-width="2" fill="none"/>
                        <ellipse class="ink-cat-paw-front" cx="184" cy="190" rx="14" ry="8.8" fill="rgba(8,8,8,0.98)"/>
                        <ellipse cx="214" cy="192" rx="12" ry="7.8" fill="rgba(8,8,8,0.95)"/>
                        <ellipse cx="268" cy="191" rx="14.2" ry="8.2" fill="rgba(8,8,8,0.95)"/>
                    </g>

                    <g class="ink-cat-head">
                        <path class="ink-cat-ear-left" d="M145,83 L132,53 L158,71 Z" fill="rgba(16,16,16,0.9)"/>
                        <path class="ink-cat-ear-right" d="M176,81 L188,53 L198,87 Z" fill="rgba(18,18,18,0.96)"/>
                        <ellipse cx="163" cy="111" rx="42" ry="34" fill="url(#inkCatWash)"/>
                        <path d="M134,113 Q124,125 131,140" stroke="rgba(225,225,225,0.12)" stroke-width="1.9" fill="none"/>

                        <g class="ink-cat-eye">
                            <ellipse cx="148" cy="106" rx="11.3" ry="11.8" fill="#d7cc86" opacity="0.92"/>
                            <ellipse class="cat-pupil" cx="148.5" cy="106" rx="3.7" ry="8.5" fill="#0b0b0b"/>
                        </g>
                        <g class="ink-cat-eye">
                            <ellipse cx="174" cy="108" rx="8" ry="9.1" fill="#d7cc86" opacity="0.82"/>
                            <ellipse class="cat-pupil" cx="174.4" cy="108" rx="2.5" ry="6.2" fill="#0b0b0b"/>
                        </g>

                        <path d="M133,120 Q118,126 111,134" stroke="rgba(218,218,218,0.42)" stroke-width="1.1" fill="none"/>
                        <path d="M134,127 Q120,136 124,143" stroke="rgba(218,218,218,0.32)" stroke-width="1.1" fill="none"/>

                        <line x1="124" y1="108" x2="86" y2="103" stroke="rgba(225,225,225,0.28)" stroke-width="0.85"/>
                        <line x1="123" y1="116" x2="83" y2="116" stroke="rgba(225,225,225,0.24)" stroke-width="0.85"/>
                        <line x1="124" y1="124" x2="90" y2="132" stroke="rgba(225,225,225,0.22)" stroke-width="0.85"/>
                    </g>
                </g>
            </svg>
        </div>
    </div>

    <script>
        // ========== 主题切换 ==========
        const themeBtn = document.getElementById('themeBtn');
        const themeMenu = document.getElementById('themeMenu');
        const themeOptions = themeMenu.querySelectorAll('.theme-option');
        
        function setTheme(theme) {
            document.body.classList.remove('theme-sky', 'theme-night');
            if (theme) {
                document.body.classList.add('theme-' + theme);
            }
            localStorage.setItem('guanyu-theme', theme);
        }
        
        const savedTheme = localStorage.getItem('guanyu-theme') || '';
        setTheme(savedTheme);
        
        themeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            themeMenu.classList.toggle('active');
        });
        
        themeOptions.forEach(opt => {
            opt.addEventListener('click', () => {
                setTheme(opt.dataset.theme);
                themeMenu.classList.remove('active');
            });
        });
        
        document.addEventListener('click', (e) => {
            if (!themeBtn.contains(e.target) && !themeMenu.contains(e.target)) {
                themeMenu.classList.remove('active');
            }
        });
        
        // ========== 诗句轮播 ==========
        const poems = [
            { line1: '鱼戏莲叶间', line2: '鱼戏莲叶东', author: '汉乐府' },
            { line1: '潭清疑水浅', line2: '荷动知鱼散', author: '储光羲' },
            { line1: '细雨鱼儿出', line2: '微风燕子斜', author: '杜甫' },
            { line1: '观鱼碧潭上', line2: '木落潭水清', author: '李白' },
            { line1: '鱼跃此时海', line2: '花开彼岸天', author: '佚名' },
            { line1: '临池观鱼戏', line2: '悠然忘世机', author: '白居易' }
        ];
        
        let currentPoemIndex = 0;
        function rotatePoem() {
            currentPoemIndex = (currentPoemIndex + 1) % poems.length;
            const poem = poems[currentPoemIndex];
            const container = document.getElementById('poemContainer');
            
            container.style.opacity = '0';
            setTimeout(() => {
                document.getElementById('poemLine1').textContent = poem.line1;
                document.getElementById('poemLine2').textContent = poem.line2;
                document.getElementById('poemAuthor').textContent = '—— ' + poem.author;
                container.style.opacity = '0.6';
            }, 500);
        }
        
        setInterval(rotatePoem, 15000);
        
        // ========== 黑猫互动 ==========
        const catContainer = document.getElementById('catContainer');
        const catEyes = document.querySelectorAll('.cat-pupil');
        const meowBubble = catContainer.querySelector('.meow-bubble');
        const catPhrases = ['看见你了', '这条不错', '别跑呀', '喵在守鱼', '给我也来点', '今日观鱼'];
        const catSoundProfiles = [
            { start: 410, mid: 560, end: 300, duration: 0.27, gain: 0.09 },
            { start: 360, mid: 480, end: 250, duration: 0.22, gain: 0.08 },
            { start: 460, mid: 690, end: 340, duration: 0.3, gain: 0.07 }
        ];
        let catActiveTimer = null;
        
        // 猫眼睛跟随鱼
        function updateCatEyes() {
            if (window.innerWidth <= 768 || fishes.length === 0) return;
            
            // 猫在右侧，优先盯着靠右(靠近它)的鱼
            let targetFish = null;
            let maxX = -Infinity;
            
            fishes.forEach(fish => {
                if (fish.x > maxX) {
                    maxX = fish.x;
                    targetFish = fish;
                }
            });
            
            if (targetFish) {
                const eyeOffsetY = targetFish.y > 56 ? 1.1 : targetFish.y < 30 ? -1.1 : 0;
                const eyeOffsetX = Math.max(-2.0, Math.min(-0.3, -1.9 + (100 - targetFish.x) * 0.04));
                
                catEyes.forEach(eye => {
                    eye.style.transform = `translate(${eyeOffsetX}px, ${eyeOffsetY}px)`;
                });
            }
        }

        function showRandomCatPhrase() {
            meowBubble.textContent = catPhrases[Math.floor(Math.random() * catPhrases.length)];
        }
        
        // 点击猫
        catContainer.addEventListener('click', () => {
            showRandomCatPhrase();
            catContainer.classList.add('active');
            playMeowSound(Math.floor(Math.random() * catSoundProfiles.length));
            
            if (catActiveTimer) clearTimeout(catActiveTimer);
            catActiveTimer = setTimeout(() => {
                catContainer.classList.remove('active');
            }, 1300);
        });
        
        // 喵声音效
        function playMeowSound(profileIndex = 0) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const profile = catSoundProfiles[profileIndex % catSoundProfiles.length];
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.type = Math.random() < 0.5 ? 'triangle' : 'sine';
                oscillator.frequency.setValueAtTime(profile.start, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(profile.mid, audioContext.currentTime + profile.duration * 0.32);
                oscillator.frequency.exponentialRampToValueAtTime(profile.end, audioContext.currentTime + profile.duration);
                
                gainNode.gain.setValueAtTime(profile.gain, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + profile.duration);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + profile.duration);
            } catch (e) {}
        }
        
        // ========== 鱼缸相关 ==========
        const tank = document.getElementById('tank');
        const waterBody = tank.querySelector('.water-body');
        const fishLayer = document.getElementById('fishLayer');
        const foodLayer = document.getElementById('foodLayer');
        const bubbleLayer = document.getElementById('bubbleLayer');
        const cursorGlow = document.getElementById('cursorGlow');
        
        let fishes = [];
        let foods = [];
        let mouseX = 0, mouseY = 0;
        let mouseXPct = 50, mouseYPct = 50;
        let isMouseInTank = false;
        let lastMouseTime = 0;
        
        const fishColors = [
            { body: '#3b82f6', tail: '#1e3a8a', name: '蓝' },
            { body: '#10b981', tail: '#064e3b', name: '翠' },
            { body: '#64748b', tail: '#0f172a', name: '墨' },
            { body: '#06b6d4', tail: '#164e63', name: '青' },
            { body: '#8b5cf6', tail: '#4c1d95', name: '紫' },
            { body: '#f59e0b', tail: '#78350f', name: '金' }
        ];

        const SWIM_PROFILES = [
            { key: 'zen', label: '禅意', speed: 1.08, eventRate: 0.78, schooling: 1.1, huntBias: 0.72, cursorInterest: 0.72, burst: 0.9 },
            { key: 'agile', label: '灵动', speed: 1.28, eventRate: 1.0, schooling: 1.0, huntBias: 1.0, cursorInterest: 1.0, burst: 1.15 },
            { key: 'playful', label: '调皮', speed: 1.45, eventRate: 1.42, schooling: 0.9, huntBias: 0.86, cursorInterest: 1.35, burst: 1.35 }
        ];
        let swimProfileIndex = 1;
        let currentSwimProfile = SWIM_PROFILES[swimProfileIndex];

        function updateSwimModeBtn() {
            const btn = document.getElementById('swimModeBtn');
            if (btn) btn.textContent = `节奏：${currentSwimProfile.label}`;
        }

        function applySwimProfileToFish(fish) {
            fish.maxSpeed = fish.baseMaxSpeed * currentSwimProfile.speed;
            fish.normalSpeed = fish.baseNormalSpeed * (0.95 + currentSwimProfile.speed * 0.25);
            fish.cruiseSpeed = fish.normalSpeed * (0.88 + Math.random() * 0.32);
            fish.burstCooldown = Math.max(36, fish.burstCooldown / currentSwimProfile.eventRate);
            fish.nextEventIn = Math.max(40, fish.nextEventIn / currentSwimProfile.eventRate);
        }

        function cycleSwimMode() {
            swimProfileIndex = (swimProfileIndex + 1) % SWIM_PROFILES.length;
            currentSwimProfile = SWIM_PROFILES[swimProfileIndex];
            updateSwimModeBtn();
            fishes.forEach(fish => applySwimProfileToFish(fish));
        }
        
        class Fish {
            constructor(x, y) {
                this.x = x || (15 + Math.random() * 70);
                this.y = y || (20 + Math.random() * 55);
                this.vx = (Math.random() - 0.5) * (0.7 + Math.random() * 0.4);
                this.vy = (Math.random() - 0.5) * (0.2 + Math.random() * 0.2);
                this.targetVx = this.vx;
                this.targetVy = this.vy;
                this.baseMaxSpeed = 2.25 + Math.random() * 0.95;
                this.baseNormalSpeed = 0.72 + Math.random() * 0.42;
                this.maxSpeed = this.baseMaxSpeed * currentSwimProfile.speed;
                this.normalSpeed = this.baseNormalSpeed * (0.95 + currentSwimProfile.speed * 0.25);
                this.dragCoeff = 0.94 + Math.random() * 0.03;
                this.size = 0.7 + Math.random() * 0.3;
                this.baseSize = this.size;
                this.colorIndex = Math.floor(Math.random() * fishColors.length);
                this.color = fishColors[this.colorIndex];
                this.eatCount = 0;
                this.growthStage = 0;
                this.behavior = 'wander';
                this.behaviorTimer = 0;
                this.nextBehaviorTime = 45 + Math.random() * 120;
                this.targetFood = null;
                this.targetFoodDist = Infinity;
                this.avoidForce = { x: 0, y: 0 };
                this.tailPhase = Math.random() * Math.PI * 2;
                this.bodyPhase = Math.random() * Math.PI * 2;
                this.speedPulsePhase = Math.random() * Math.PI * 2;
                this.tailFrequency = 0.09 + Math.random() * 0.035;
                this.tailAmplitudeBase = 5 + Math.random() * 2.4;
                this.preferredDepth = 22 + Math.random() * 58;
                this.depthWanderTimer = 120 + Math.random() * 220;
                this.wanderTurnInterval = 16 + Math.random() * 20;
                this.cruiseSpeed = this.normalSpeed * (0.9 + Math.random() * 0.35);
                this.turnMemory = Math.atan2(this.vy, this.vx);
                this.burstCooldown = 120 + Math.random() * 180;
                this.schoolForce = { x: 0, y: 0 };
                this.personality = {
                    curiosity: 0.35 + Math.random() * 0.65,
                    playfulness: 0.3 + Math.random() * 0.7,
                    sociability: 0.35 + Math.random() * 0.65,
                    boldness: 0.25 + Math.random() * 0.75,
                    appetite: 0.18 + Math.random() * 0.95,
                    competitiveness: 0.15 + Math.random() * 0.9
                };
                this.hunger = 0.35 + Math.random() * 0.65;
                this.foodCooldown = 0;
                this.eventType = null;
                this.eventTimer = 0;
                this.eventDuration = 0;
                this.eventData = null;
                this.nextEventIn = (100 + Math.random() * 260) / currentSwimProfile.eventRate;
                this.peerNudgeCooldown = 50 + Math.random() * 110;
                this.eyeBlinkTimer = 0;
                this.eyeBlinkDuration = 0;
                this.blinkDurationFrames = 8 + Math.random() * 4;
                this.nextBlinkTime = 55 + Math.random() * 150;
                this.isBlinking = false;
                this.pupilPhase = Math.random() * Math.PI * 2;
                this.mouthPhase = Math.random() * Math.PI * 2;
                this.element = this.createSVGElement();
            }
            
            createSVGElement() {
                const div = document.createElement('div');
                div.className = 'fish';
                div.style.width = '80px';
                div.style.height = '40px';
                
                const svgNS = "http://www.w3.org/2000/svg";
                const svg = document.createElementNS(svgNS, 'svg');
                svg.setAttribute('viewBox', '0 0 120 60');
                svg.style.overflow = 'visible';
                
                const defs = document.createElementNS(svgNS, 'defs');
                const gradId = `grad-${this.color.name}-${Math.floor(Math.random()*1000)}`;
                defs.innerHTML = `
                    <linearGradient id="${gradId}" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:${this.color.tail}" />
                        <stop offset="50%" style="stop-color:${this.color.body}" />
                        <stop offset="100%" style="stop-color:${this.color.body}" />
                    </linearGradient>
                `;
                svg.appendChild(defs);
                
                const tail = document.createElementNS(svgNS, 'path');
                tail.setAttribute('d', 'M 10,30 Q -5,15 2,30 Q -8,45 10,30 Z');
                tail.setAttribute('fill', this.color.tail);
                tail.style.transformOrigin = '10px 30px';
                this.tailElement = tail;
                svg.appendChild(tail);
                
                const dorsal = document.createElementNS(svgNS, 'path');
                dorsal.setAttribute('d', 'M 35,14 Q 50,2 70,14 L 65,25 Q 50,18 40,25 Z');
                dorsal.setAttribute('fill', this.color.tail);
                dorsal.setAttribute('opacity', '0.8');
                dorsal.style.transformOrigin = '52px 20px';
                this.dorsalElement = dorsal;
                svg.appendChild(dorsal);
                
                const pectoralLeft = document.createElementNS(svgNS, 'path');
                pectoralLeft.setAttribute('d', 'M 45,38 Q 35,42 38,52');
                pectoralLeft.setAttribute('stroke', this.color.tail);
                pectoralLeft.setAttribute('stroke-width', '2');
                pectoralLeft.setAttribute('fill', 'none');
                pectoralLeft.setAttribute('opacity', '0.6');
                pectoralLeft.style.transformOrigin = '45px 38px';
                this.pectoralLeftElement = pectoralLeft;
                svg.appendChild(pectoralLeft);
                
                const pectoralRight = document.createElementNS(svgNS, 'path');
                pectoralRight.setAttribute('d', 'M 45,22 Q 35,18 38,8');
                pectoralRight.setAttribute('stroke', this.color.tail);
                pectoralRight.setAttribute('stroke-width', '2');
                pectoralRight.setAttribute('fill', 'none');
                pectoralRight.setAttribute('opacity', '0.6');
                pectoralRight.style.transformOrigin = '45px 22px';
                this.pectoralRightElement = pectoralRight;
                svg.appendChild(pectoralRight);
                
                const body = document.createElementNS(svgNS, 'ellipse');
                body.setAttribute('cx', '62');
                body.setAttribute('cy', '30');
                body.setAttribute('rx', '42');
                body.setAttribute('ry', '24');
                body.setAttribute('fill', `url(#${gradId})`);
                this.bodyElement = body;
                svg.appendChild(body);
                
                const scales = document.createElementNS(svgNS, 'g');
                scales.setAttribute('opacity', '0.1');
                for(let i=0; i<4; i++) {
                    for(let j=0; j<2; j++) {
                        const path = document.createElementNS(svgNS, 'path');
                        path.setAttribute('d', `M ${40+i*10},${20+j*14} Q ${45+i*10},${27+j*14} ${40+i*10},${34+j*14}`);
                        path.setAttribute('stroke', 'white');
                        path.setAttribute('fill', 'none');
                        scales.appendChild(path);
                    }
                }
                svg.appendChild(scales);
                
                const eyeGroup = document.createElementNS(svgNS, 'g');
                this.eyeGroup = eyeGroup;
                
                const eyeWhite = document.createElementNS(svgNS, 'ellipse');
                eyeWhite.setAttribute('cx', '92');
                eyeWhite.setAttribute('cy', '20');
                eyeWhite.setAttribute('rx', '6');
                eyeWhite.setAttribute('ry', '6');
                eyeWhite.setAttribute('fill', 'white');
                this.eyeWhite = eyeWhite;
                
                const eyeBlack = document.createElementNS(svgNS, 'ellipse');
                eyeBlack.setAttribute('cx', '94');
                eyeBlack.setAttribute('cy', '20');
                eyeBlack.setAttribute('rx', '3');
                eyeBlack.setAttribute('ry', '3');
                eyeBlack.setAttribute('fill', '#0f172a');
                this.eyeBlack = eyeBlack;
                
                const eyeShine = document.createElementNS(svgNS, 'circle');
                eyeShine.setAttribute('cx', '95');
                eyeShine.setAttribute('cy', '19');
                eyeShine.setAttribute('r', '1.5');
                eyeShine.setAttribute('fill', 'white');
                this.eyeShine = eyeShine;
                
                eyeGroup.appendChild(eyeWhite);
                eyeGroup.appendChild(eyeBlack);
                eyeGroup.appendChild(eyeShine);
                svg.appendChild(eyeGroup);
                
                const mouth = document.createElementNS(svgNS, 'path');
                mouth.setAttribute('d', 'M 105,32 Q 108,30 105,28');
                mouth.setAttribute('stroke', '#0f172a');
                mouth.setAttribute('stroke-width', '1.5');
                mouth.setAttribute('fill', 'none');
                mouth.setAttribute('opacity', '0.4');
                this.mouthElement = mouth;
                svg.appendChild(mouth);
                
                div.appendChild(svg);
                fishLayer.appendChild(div);
                return div;
            }
            
            update() {
                this.behaviorTimer++;
                this.depthWanderTimer--;
                this.burstCooldown--;
                this.nextEventIn--;
                this.peerNudgeCooldown--;
                this.speedPulsePhase += 0.015;
                this.hunger = Math.min(1, this.hunger + 0.0008 + this.personality.appetite * 0.0006);
                this.foodCooldown = Math.max(0, this.foodCooldown - 0.08);

                if (this.depthWanderTimer <= 0) {
                    this.preferredDepth = 16 + Math.random() * 70;
                    this.depthWanderTimer = 160 + Math.random() * 260;
                }

                if (this.behaviorTimer >= this.nextBehaviorTime) {
                    this.chooseBehavior();
                    this.behaviorTimer = 0;
                }
                
                if (foods.length > 0 && this.behaviorTimer % 3 === 0 && !this.targetFood) {
                    this.findNearestFood();
                }
                
                if (foods.length > 0 && this.behaviorTimer % 15 === 0) {
                    this.tryRandomFoodHunt();
                }
                
                if (this.targetFood && !document.body.contains(this.targetFood.element)) {
                    this.targetFood = null;
                }
                if (this.targetFood) {
                    const dxFood = this.targetFood.x - this.x;
                    const dyFood = this.targetFood.y - this.y;
                    const distFood = Math.sqrt(dxFood * dxFood + dyFood * dyFood);
                    if (!this.shouldChaseFood(distFood, true)) {
                        this.targetFood = null;
                        if (this.behavior === 'hunt') this.behavior = 'wander';
                    } else {
                        this.targetFoodDist = distFood;
                    }
                }
                
                if (this.behavior === 'wander' && Math.random() < 0.03) {
                    this.targetVy += (Math.random() - 0.5) * 0.4;
                }
                
                if (Math.random() < 0.007) {
                    this.targetVx += (Math.random() - 0.5) * 1;
                    this.targetVy += (Math.random() - 0.5) * 1;
                }

                if (this.behavior !== 'hunt' && this.behavior !== 'flee') {
                    this.applyDepthPreference();
                }
                
                switch(this.behavior) {
                    case 'wander':
                        this.wanderBehavior();
                        break;
                    case 'hunt':
                        this.huntBehavior();
                        break;
                    case 'flee':
                        this.fleeBehavior();
                        break;
                    case 'rest':
                        this.restBehavior();
                        break;
                }

                this.updateRandomEvent();
                
                if (this.behaviorTimer % 5 === 0) {
                    this.updateAvoidance();
                } else {
                    this.avoidForce.x *= 0.9;
                    this.avoidForce.y *= 0.9;
                }

                if (this.behaviorTimer % 6 === 0) {
                    this.updateSchooling();
                } else {
                    this.schoolForce.x *= 0.86;
                    this.schoolForce.y *= 0.86;
                }

                if (this.behaviorTimer % 18 === 0) {
                    this.maybePlayWithNeighbor();
                }
                
                this.targetVx += this.avoidForce.x;
                this.targetVy += this.avoidForce.y;
                this.targetVx += this.schoolForce.x;
                this.targetVy += this.schoolForce.y;

                if (isMouseInTank && !this.targetFood && this.behavior === 'wander') {
                    const cursorDx = mouseXPct - this.x;
                    const cursorDy = mouseYPct - this.y;
                    const cursorDist = Math.sqrt(cursorDx * cursorDx + cursorDy * cursorDy);
                    if (cursorDist < 24 && cursorDist > 0.2) {
                        const cursorPull = (24 - cursorDist) / 24 * 0.03 * currentSwimProfile.cursorInterest;
                        this.targetVx += (cursorDx / cursorDist) * cursorPull;
                        this.targetVy += (cursorDy / cursorDist) * cursorPull * 0.55;
                    }
                }
                
                let vyBoost = 1;
                if (this.targetVy > 0.2) vyBoost = 1.2;
                
                let targetSpeed = Math.sqrt(this.targetVx * this.targetVx + this.targetVy * this.targetVy);
                const speedCap = this.maxSpeed * vyBoost;
                if (targetSpeed > speedCap) {
                    this.targetVx = (this.targetVx / targetSpeed) * speedCap;
                    this.targetVy = (this.targetVy / targetSpeed) * speedCap;
                }
                
                this.vx += (this.targetVx - this.vx) * 0.08;
                this.vy += (this.targetVy - this.vy) * 0.08;
                
                this.vx *= this.dragCoeff;
                this.vy *= this.dragCoeff;
                
                this.handleBoundaries();
                
                const movementStep = 0.108 * currentSwimProfile.speed;
                this.x += this.vx * movementStep;
                this.y += this.vy * movementStep;
                
                this.x = Math.max(3, Math.min(97, this.x));
                this.y = Math.max(8, Math.min(92, this.y));
                
                this.updateAnimation();
                this.updateTransform();
            }

            updateRandomEvent() {
                if (this.targetFood || this.behavior === 'hunt' || this.behavior === 'flee') {
                    if (this.eventType) this.finishEvent(0.9);
                    return;
                }

                if (!this.eventType) {
                    this.tryStartRandomEvent();
                    return;
                }

                this.eventTimer++;
                const t = this.eventTimer / Math.max(1, this.eventDuration);

                switch (this.eventType) {
                    case 'dart':
                        this.handleDartEvent(t);
                        break;
                    case 'orbit':
                        this.handleOrbitEvent(t);
                        break;
                    case 'surfaceSip':
                        this.handleSurfaceSipEvent(t);
                        break;
                    case 'chaseFriend':
                        this.handleChaseFriendEvent(t);
                        break;
                    case 'inspectCursor':
                        this.handleInspectCursorEvent(t);
                        break;
                    case 'bottomPeck':
                        this.handleBottomPeckEvent(t);
                        break;
                    case 'zigzag':
                        this.handleZigzagEvent(t);
                        break;
                }

                if (this.eventTimer >= this.eventDuration) {
                    this.finishEvent();
                }
            }

            tryStartRandomEvent() {
                if (this.nextEventIn > 0) return;

                const baseChance = (0.2 + this.personality.playfulness * 0.36) * currentSwimProfile.eventRate;
                if (Math.random() > baseChance) {
                    this.nextEventIn = (90 + Math.random() * 220) / currentSwimProfile.eventRate;
                    return;
                }

                const events = ['dart', 'orbit', 'zigzag', 'bottomPeck'];
                if (this.personality.sociability > 0.45) events.push('chaseFriend');
                if (this.personality.curiosity > 0.35 && isMouseInTank) events.push('inspectCursor');
                if (this.personality.boldness > 0.4) events.push('surfaceSip');

                const choice = events[Math.floor(Math.random() * events.length)];
                this.startEvent(choice);
            }

            startEvent(type) {
                this.eventType = type;
                this.eventTimer = 0;
                this.eventData = {};
                this.behavior = 'wander';

                if (type === 'dart') {
                    this.eventDuration = 18 + Math.floor(Math.random() * 20);
                    this.eventData.angle = Math.atan2(this.vy, this.vx || 0.0001) + (Math.random() - 0.5) * 0.9;
                } else if (type === 'orbit') {
                    this.eventDuration = 85 + Math.floor(Math.random() * 90);
                    this.eventData.centerX = this.x + (Math.random() - 0.5) * 10;
                    this.eventData.centerY = this.y + (Math.random() - 0.5) * 8;
                    this.eventData.radius = 3.5 + Math.random() * 5.5;
                    this.eventData.dir = Math.random() < 0.5 ? -1 : 1;
                } else if (type === 'surfaceSip') {
                    this.eventDuration = 90 + Math.floor(Math.random() * 80);
                    this.eventData.sipped = false;
                    this.eventData.sideDrift = (Math.random() - 0.5) * 0.5;
                } else if (type === 'chaseFriend') {
                    this.eventDuration = 70 + Math.floor(Math.random() * 80);
                    this.eventData.targetFish = this.findNearbyFish(36);
                    if (!this.eventData.targetFish) {
                        this.finishEvent(0.9);
                        return;
                    }
                    this.eventData.offset = 3 + Math.random() * 4;
                } else if (type === 'inspectCursor') {
                    this.eventDuration = 60 + Math.floor(Math.random() * 70);
                    this.eventData.orbitDir = Math.random() < 0.5 ? -1 : 1;
                    this.eventData.orbitSize = 2 + Math.random() * 3.5;
                } else if (type === 'bottomPeck') {
                    this.eventDuration = 70 + Math.floor(Math.random() * 90);
                    this.eventData.pecked = false;
                } else if (type === 'zigzag') {
                    this.eventDuration = 65 + Math.floor(Math.random() * 75);
                    this.eventData.heading = Math.atan2(this.vy, this.vx || 0.0001);
                    this.eventData.phase = Math.random() * Math.PI * 2;
                }
            }

            finishEvent(cooldownScale = 1) {
                this.eventType = null;
                this.eventData = null;
                this.eventTimer = 0;
                this.eventDuration = 0;
                const minCooldown = 85 + Math.random() * 220;
                this.nextEventIn = minCooldown / Math.max(0.4, cooldownScale) / (0.8 + this.personality.playfulness * 0.6) / currentSwimProfile.eventRate;
            }

            handleDartEvent(t) {
                const ease = Math.max(0.2, 1 - t);
                const burst = this.maxSpeed * (0.75 + this.personality.boldness * 0.45) * ease;
                this.targetVx = Math.cos(this.eventData.angle) * burst;
                this.targetVy = Math.sin(this.eventData.angle) * burst * 0.75;
            }

            handleOrbitEvent(t) {
                const cx = this.eventData.centerX;
                const cy = this.eventData.centerY;
                const dx = cx - this.x;
                const dy = cy - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 0.0001;
                const radial = (dist - this.eventData.radius) * 0.08;
                const tangential = this.eventData.dir * (0.26 + this.personality.playfulness * 0.22);
                this.targetVx += (dx / dist) * radial + (-dy / dist) * tangential;
                this.targetVy += (dy / dist) * radial + (dx / dist) * tangential * 0.72;
                this.targetVy += Math.sin(t * Math.PI * 2) * 0.02;
            }

            handleSurfaceSipEvent(t) {
                if (this.y > 15) {
                    this.targetVy -= 0.2 + this.personality.boldness * 0.18;
                } else {
                    this.targetVy += 0.03;
                    this.targetVx += this.eventData.sideDrift;
                    if (!this.eventData.sipped) {
                        this.eventData.sipped = true;
                        createBubble(this.x, Math.max(10, this.y - 1));
                        const ripple = document.createElement('div');
                        ripple.className = 'water-ripple';
                        ripple.style.left = this.x + '%';
                        ripple.style.top = Math.max(6, this.y - 2) + '%';
                        waterBody.appendChild(ripple);
                        setTimeout(() => ripple.remove(), 1800);
                    }
                }

                if (t > 0.6) {
                    this.targetVy += (this.preferredDepth - this.y) * 0.02;
                }
            }

            handleChaseFriendEvent() {
                const buddy = this.eventData.targetFish;
                if (!buddy || buddy === this) {
                    this.finishEvent(0.9);
                    return;
                }
                const heading = Math.atan2(buddy.vy, buddy.vx || 0.0001);
                const tx = buddy.x - Math.cos(heading) * this.eventData.offset;
                const ty = buddy.y - Math.sin(heading) * this.eventData.offset * 0.6;
                const dx = tx - this.x;
                const dy = ty - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 0.0001;
                const speed = Math.min(this.maxSpeed * 0.8, 0.35 + dist * 0.08);
                this.targetVx = (dx / dist) * speed;
                this.targetVy = (dy / dist) * speed * 0.75;
            }

            handleInspectCursorEvent(t) {
                if (!isMouseInTank) {
                    this.finishEvent(0.85);
                    return;
                }
                const angle = t * Math.PI * 2 * this.eventData.orbitDir;
                const tx = mouseXPct + Math.cos(angle) * this.eventData.orbitSize;
                const ty = mouseYPct + Math.sin(angle) * this.eventData.orbitSize * 0.7;
                const dx = tx - this.x;
                const dy = ty - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 0.0001;
                const speed = Math.min(this.maxSpeed * 0.75, 0.28 + dist * 0.07);
                this.targetVx = (dx / dist) * speed;
                this.targetVy = (dy / dist) * speed * 0.72;
            }

            handleBottomPeckEvent(t) {
                const targetBottom = 85;
                if (this.y < targetBottom) {
                    this.targetVy += 0.16;
                } else {
                    this.targetVy -= 0.05;
                    this.targetVx += Math.sin(this.tailPhase * 1.8) * 0.06;
                    if (!this.eventData.pecked && t > 0.45) {
                        this.eventData.pecked = true;
                        createBubble(this.x, this.y);
                    }
                }
            }

            handleZigzagEvent() {
                this.eventData.phase += 0.2 + this.personality.playfulness * 0.09;
                const base = this.eventData.heading;
                const zig = Math.sin(this.eventData.phase) * (0.55 + this.personality.playfulness * 0.35);
                const angle = base + zig;
                const speed = this.normalSpeed * (1.05 + this.personality.playfulness * 0.5);
                this.targetVx = Math.cos(angle) * speed;
                this.targetVy = Math.sin(angle) * speed * 0.72;
            }

            findNearbyFish(radius) {
                let nearest = null;
                let minDist = radius * radius;
                for (let i = 0; i < fishes.length; i++) {
                    const other = fishes[i];
                    if (other === this) continue;
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq < minDist) {
                        minDist = distSq;
                        nearest = other;
                    }
                }
                return nearest;
            }

            maybePlayWithNeighbor() {
                if (this.peerNudgeCooldown > 0 || this.behavior === 'flee' || this.targetFood) return;
                const mate = this.findNearbyFish(8);
                if (!mate) return;
                if (Math.random() > (0.18 + this.personality.playfulness * 0.35) * currentSwimProfile.eventRate) return;

                const dx = this.x - mate.x;
                const dy = this.y - mate.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 0.0001;
                const nudge = 0.16 + this.personality.playfulness * 0.18;
                this.targetVx += (dx / dist) * nudge;
                this.targetVy += (dy / dist) * nudge * 0.8;
                this.targetVx += (Math.random() - 0.5) * 0.22;
                this.targetVy += (Math.random() - 0.5) * 0.15;
                this.peerNudgeCooldown = (120 + Math.random() * 180) / currentSwimProfile.eventRate;
            }

            applyDepthPreference() {
                const depthDiff = this.preferredDepth - this.y;
                const pull = Math.max(-0.18, Math.min(0.18, depthDiff * 0.01));
                this.targetVy += pull * 0.4;
            }

            getFoodDrive() {
                const appetite = this.personality.appetite;
                const curiosityBoost = this.personality.curiosity * 0.22;
                const cooldownPenalty = this.foodCooldown * 0.03;
                const drive = this.hunger * (0.58 + appetite * 0.62) + curiosityBoost - cooldownPenalty;
                return Math.max(0, drive * currentSwimProfile.huntBias);
            }

            shouldChaseFood(distance, forcedNotice = false) {
                if (this.behavior === 'flee') return false;
                const drive = this.getFoodDrive();
                const nearBoost = Math.max(0, (38 - distance) / 38) * 0.38;
                const competitiveness = this.personality.competitiveness * 0.24;
                const desirability = drive * 0.58 + nearBoost + competitiveness;
                if (forcedNotice) return desirability > 0.2;
                if (drive < 0.28) return false;
                const chance = Math.max(0.06, Math.min(0.96, desirability));
                return Math.random() < chance;
            }
            
            findNearestFood() {
                let nearest = null;
                let minDist = Infinity;
                const searchRadius = 24 + Math.random() * 12;
                
                for (let i = 0; i < foods.length; i++) {
                    const food = foods[i];
                    const isFoodTaken = fishes.some(f => f.targetFood === food && f !== this);
                    
                    const dx = food.x - this.x;
                    const dy = food.y - this.y;
                    const dist = dx*dx + dy*dy;
                    const distReal = Math.sqrt(dist);
                    
                    const effectiveRadius = isFoodTaken ? searchRadius * 0.5 : searchRadius;
                    if (!this.shouldChaseFood(distReal, false)) continue;
                    
                    if (dist < minDist && dist < effectiveRadius * effectiveRadius) {
                        minDist = dist;
                        nearest = food;
                    }
                }
                
                if (nearest) {
                    this.targetFood = nearest;
                    this.targetFoodDist = Math.sqrt(minDist);
                }
            }
            
            tryRandomFoodHunt() {
                if (foods.length === 0 || Math.random() > 0.1) return;
                
                const randomFood = foods[Math.floor(Math.random() * foods.length)];
                const dx = randomFood.x - this.x;
                const dy = randomFood.y - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (!this.shouldChaseFood(dist, false)) return;
                
                if (dist < 35 + Math.random() * 15) {
                    this.targetFood = randomFood;
                    this.targetFoodDist = dist;
                    this.behavior = 'hunt';
                    this.nextBehaviorTime = 140 + Math.random() * 80;
                }
            }
            
            updateAvoidance() {
                this.avoidForce.x = 0;
                this.avoidForce.y = 0;
                
                const avoidRadius = 10 + Math.random() * 4;
                const avoidRadiusSq = avoidRadius * avoidRadius;
                
                for (let i = 0; i < fishes.length; i++) {
                    const other = fishes[i];
                    if (other === this) continue;
                    
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const distSq = dx*dx + dy*dy;
                    
                    if (distSq < avoidRadiusSq && distSq > 0.1) {
                        const dist = Math.sqrt(distSq);
                        const force = (avoidRadius - dist) / avoidRadius;
                        const forceStrengthX = 0.1 + Math.random() * 0.06;
                        const forceStrengthY = 0.08 + Math.random() * 0.04;
                        this.avoidForce.x -= (dx / dist) * force * forceStrengthX;
                        this.avoidForce.y -= (dy / dist) * force * forceStrengthY;
                    }
                }
            }

            updateSchooling() {
                this.schoolForce.x = 0;
                this.schoolForce.y = 0;
                if (fishes.length < 2 || this.behavior === 'flee') return;

                const schoolRadius = 24;
                const schoolRadiusSq = schoolRadius * schoolRadius;
                let neighbors = 0;
                let alignX = 0;
                let alignY = 0;
                let cohesionX = 0;
                let cohesionY = 0;

                for (let i = 0; i < fishes.length; i++) {
                    const other = fishes[i];
                    if (other === this) continue;

                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq > schoolRadiusSq || distSq < 0.2) continue;

                    neighbors++;
                    alignX += other.vx;
                    alignY += other.vy;
                    cohesionX += other.x;
                    cohesionY += other.y;
                }

                if (neighbors === 0) return;

                alignX /= neighbors;
                alignY /= neighbors;
                cohesionX = (cohesionX / neighbors) - this.x;
                cohesionY = (cohesionY / neighbors) - this.y;

                this.schoolForce.x = alignX * 0.02 + cohesionX * 0.004;
                this.schoolForce.y = alignY * 0.018 + cohesionY * 0.003;
                this.schoolForce.x *= currentSwimProfile.schooling;
                this.schoolForce.y *= currentSwimProfile.schooling;
            }
            
            handleBoundaries() {
                const hardMargin = 2;
                const softMargin = 10;
                
                let needsTurn = false;
                
                if (this.x < softMargin) {
                    needsTurn = true;
                    this.targetVx = Math.abs(this.targetVx) + (Math.random() - 0.5) * 0.2;
                } else if (this.x > 100 - softMargin) {
                    needsTurn = true;
                    this.targetVx = -Math.abs(this.targetVx) - (Math.random() - 0.5) * 0.2;
                }
                
                if (this.y < softMargin) {
                    needsTurn = true;
                    this.targetVy = Math.abs(this.targetVy) + (Math.random() - 0.5) * 0.15;
                } else if (this.y > 95 - softMargin) {
                    needsTurn = true;
                    this.targetVy = -Math.abs(this.targetVy) - (Math.random() - 0.5) * 0.15;
                }
                
                if (needsTurn && (this.behavior !== 'flee' && this.behavior !== 'hunt')) {
                    this.behavior = 'flee';
                    this.nextBehaviorTime = 25 + Math.random() * 30;
                }
                
                if (this.x < hardMargin) {
                    this.x = hardMargin;
                    this.vx = Math.abs(this.vx) * 0.5;
                } else if (this.x > 100 - hardMargin) {
                    this.x = 100 - hardMargin;
                    this.vx = -Math.abs(this.vx) * 0.5;
                }
                
                if (this.y < hardMargin) {
                    this.y = hardMargin;
                    this.vy = Math.abs(this.vy) * 0.5;
                } else if (this.y > 95 - hardMargin) {
                    this.y = 95 - hardMargin;
                    this.vy = -Math.abs(this.vy) * 0.5;
                }
            }
            
            chooseBehavior() {
                if (this.targetFood && this.targetFoodDist < 24 + Math.random() * 6) {
                    this.behavior = 'hunt';
                    this.nextBehaviorTime = 120 + Math.random() * 100;
                } else {
                    const rand = Math.random();
                    if (rand < 0.5 + Math.random() * 0.1) {
                        this.behavior = 'wander';
                        this.nextBehaviorTime = 50 + Math.random() * 130;
                    } else if (rand < 0.8 + Math.random() * 0.1) {
                        this.behavior = 'rest';
                        this.nextBehaviorTime = 25 + Math.random() * 80;
                    } else {
                        this.behavior = 'flee';
                        this.nextBehaviorTime = 15 + Math.random() * 50;
                    }
                }
            }
            
            wanderBehavior() {
                const interval = Math.floor(this.wanderTurnInterval);
                if (interval > 0 && this.behaviorTimer % interval === 0) {
                    const angleVariation = (Math.random() - 0.5) * 0.32;
                    const currentAngle = Math.atan2(this.vy, this.vx || 0.0001);
                    const newAngle = currentAngle + angleVariation;
                    const cruiseFactor = 0.86 + Math.sin(this.speedPulsePhase) * 0.2;
                    const newSpeed = Math.max(0.22, this.cruiseSpeed * cruiseFactor);

                    this.targetVx = Math.cos(newAngle) * newSpeed;
                    this.targetVy = Math.sin(newAngle) * newSpeed * 0.72;
                }

                if (this.burstCooldown <= 0 && Math.random() < 0.008) {
                    const heading = Math.atan2(this.targetVy, this.targetVx || 0.0001);
                    const burstSpeed = this.maxSpeed * currentSwimProfile.burst * (0.48 + Math.random() * 0.16);
                    this.targetVx = Math.cos(heading) * burstSpeed;
                    this.targetVy = Math.sin(heading) * burstSpeed * 0.78;
                    this.burstCooldown = (150 + Math.random() * 230) / currentSwimProfile.eventRate;
                }
            }
            
            huntBehavior() {
                if (!this.targetFood) {
                    this.behavior = 'wander';
                    return;
                }
                const dx = this.targetFood.x - this.x;
                const dy = this.targetFood.y - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const eatDistance = 2 + Math.random() * 0.8;
                
                if (dist < eatDistance) {
                    const eatenCount = this.consumeNearbyFoods(this.targetFood);
                    this.targetFood = null;

                    if (eatenCount > 0) {
                        createBubble(this.x, this.y);

                        if (foods.length > 0 && this.getFoodDrive() > 0.35) {
                            this.findNearestFood();
                        }

                        if (this.targetFood) {
                            this.behavior = 'hunt';
                            this.nextBehaviorTime = 80 + Math.random() * 90;
                        } else {
                            this.behavior = 'rest';
                            this.nextBehaviorTime = 18 + Math.random() * 30;
                        }
                    } else {
                        this.behavior = 'wander';
                    }
                } else {
                    const targetAngle = Math.atan2(dy, dx);
                    const huntSpeed = this.maxSpeed * (0.68 + Math.random() * 0.16);
                    this.targetVx = Math.cos(targetAngle) * huntSpeed;
                    this.targetVy = Math.sin(targetAngle) * huntSpeed * (0.5 + Math.random() * 0.16);
                }
            }

            consumeNearbyFoods(primaryFood) {
                if (!primaryFood) return 0;

                const biteRadius = 2.5 + this.personality.appetite * 2.4;
                const biteLimit = 1 + Math.floor(this.personality.competitiveness * 2 + Math.random() * 2);
                const cx = primaryFood.x;
                const cy = primaryFood.y;

                const candidates = foods
                    .map(food => {
                        const dx = food.x - cx;
                        const dy = food.y - cy;
                        return { food, dist: Math.sqrt(dx * dx + dy * dy) };
                    })
                    .filter(item => item.dist <= biteRadius)
                    .sort((a, b) => a.dist - b.dist)
                    .slice(0, biteLimit);

                let eaten = 0;
                for (let i = 0; i < candidates.length; i++) {
                    if (this.consumeSingleFood(candidates[i].food)) {
                        eaten++;
                    }
                }

                return eaten;
            }

            consumeSingleFood(foodObj) {
                if (!foodObj || !document.body.contains(foodObj.element)) return false;

                foodObj.element.remove();
                foods = foods.filter(f => f !== foodObj);

                this.hunger = Math.max(0.03, this.hunger - (0.22 + this.personality.appetite * 0.16));
                this.foodCooldown = 12 + Math.random() * 12;

                this.eatCount = (this.eatCount || 0) + 1;

                if (this.eatCount < 5) {
                    this.size = Math.min(this.size * (1.03 + Math.random() * 0.008), this.baseSize * 1.12);
                    this.growthStage = 0;
                } else if (this.eatCount < 12) {
                    this.size = Math.min(this.size * (1.018 + Math.random() * 0.008), this.baseSize * 1.28);
                    this.growthStage = 1;
                } else {
                    if (this.growthStage < 2) {
                        this.colorIndex = (this.colorIndex + 1) % fishColors.length;
                        this.color = fishColors[this.colorIndex];
                        this.updateColor();
                        this.element.style.filter = 'drop-shadow(0 0 12px #fbbf24) brightness(1.1)';
                        setTimeout(() => {
                            this.element.style.filter = 'drop-shadow(0 4px 8px rgba(0,0,0,0.08))';
                        }, 600);
                    }
                    this.size = Math.min(this.size * (1.006 + Math.random() * 0.008), this.baseSize * 1.4);
                    this.growthStage = 2;
                }

                return true;
            }
            
            updateColor() {
                const svg = this.element.querySelector('svg');
                const grad = svg.querySelector('linearGradient');
                grad.innerHTML = `
                    <stop offset="0%" style="stop-color:${this.color.tail}" />
                    <stop offset="50%" style="stop-color:${this.color.body}" />
                    <stop offset="100%" style="stop-color:${this.color.body}" />
                `;
                this.tailElement.setAttribute('fill', this.color.tail);
                this.dorsalElement.setAttribute('fill', this.color.tail);
                this.pectoralLeftElement.setAttribute('stroke', this.color.tail);
                this.pectoralRightElement.setAttribute('stroke', this.color.tail);
                this.bodyElement.setAttribute('fill', `url(#${grad.id})`);
            }
            
            restBehavior() {
                const decelFactor = 0.88 + Math.random() * 0.04;
                this.targetVx *= decelFactor;
                this.targetVy *= decelFactor;
            }
            
            fleeBehavior() {
                if (this.behaviorTimer === 0) {
                    const angle = (Math.random() - 0.5) * Math.PI * (0.75 + Math.random() * 0.4);
                    const fleeSpeed = this.maxSpeed * (0.68 + Math.random() * 0.25);
                    this.targetVx = Math.cos(angle) * fleeSpeed;
                    this.targetVy = Math.sin(angle) * fleeSpeed * (0.45 + Math.random() * 0.25);
                }
            }
            
            updateAnimation() {
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                
                this.tailPhase += this.tailFrequency + speed * 0.08;
                const tailAngle = Math.sin(this.tailPhase) * (this.tailAmplitudeBase + speed * 6.5);
                this.tailElement.style.transform = `rotate(${tailAngle}deg)`;
                
                this.bodyPhase += 0.015 + speed * 0.009;
                const breath = 1 + Math.sin(this.bodyPhase) * 0.017;
                this.bodyElement.style.transform = `scale(${breath})`;
                
                const dorsalAngle = Math.sin(this.tailPhase * 0.46) * (3.6 + speed * 3);
                this.dorsalElement.style.transform = `rotate(${dorsalAngle}deg)`;
                
                const pectoralAngle = Math.sin(this.bodyPhase * 1.35 + speed * 0.2) * (9 + speed * 5);
                this.pectoralLeftElement.style.transform = `rotate(${pectoralAngle}deg)`;
                this.pectoralRightElement.style.transform = `rotate(${-pectoralAngle}deg)`;

                this.pupilPhase += 0.08 + speed * 0.03;
                let gazeX = Math.max(-1.4, Math.min(1.4, this.vx * 1.1));
                let gazeY = Math.max(-1.1, Math.min(1.1, this.vy * 0.9));
                if (this.eventType === 'inspectCursor' && isMouseInTank) {
                    const dx = mouseXPct - this.x;
                    const dy = mouseYPct - this.y;
                    gazeX = Math.max(-1.8, Math.min(1.8, dx * 0.09));
                    gazeY = Math.max(-1.4, Math.min(1.4, dy * 0.08));
                } else {
                    gazeX += Math.sin(this.pupilPhase) * 0.25;
                    gazeY += Math.cos(this.pupilPhase * 0.7) * 0.18;
                }
                this.eyeBlack.setAttribute('cx', (94 + gazeX).toFixed(2));
                this.eyeBlack.setAttribute('cy', (20 + gazeY).toFixed(2));
                this.eyeShine.setAttribute('cx', (95 + gazeX * 0.5).toFixed(2));
                this.eyeShine.setAttribute('cy', (19 + gazeY * 0.3).toFixed(2));

                this.mouthPhase += 0.04 + speed * 0.02;
                const mouthOpen = 0.5 + Math.sin(this.mouthPhase) * 0.6 + (this.eventType === 'surfaceSip' ? 0.5 : 0);
                const mouthTop = (30 - mouthOpen).toFixed(2);
                const mouthBottom = (30 + mouthOpen).toFixed(2);
                this.mouthElement.setAttribute('d', `M 105,${mouthBottom} Q 108,30 105,${mouthTop}`);
                
                this.eyeBlinkTimer++;
                
                if (this.eyeBlinkTimer >= this.nextBlinkTime) {
                    this.isBlinking = true;
                    this.eyeBlinkDuration = 0;
                    this.eyeBlinkTimer = 0;
                    this.blinkDurationFrames = 7 + Math.random() * 4;
                    this.nextBlinkTime = 60 + Math.random() * 160;
                }
                
                let eyeScale = 1;
                
                if (this.isBlinking) {
                    this.eyeBlinkDuration++;
                    const blinkDuration = this.blinkDurationFrames;
                    
                    if (this.eyeBlinkDuration < blinkDuration / 2) {
                        eyeScale = 1 - (this.eyeBlinkDuration / (blinkDuration / 2));
                    } else if (this.eyeBlinkDuration < blinkDuration) {
                        eyeScale = (this.eyeBlinkDuration - blinkDuration / 2) / (blinkDuration / 2);
                    } else {
                        this.isBlinking = false;
                        eyeScale = 1;
                    }
                }
                
                this.eyeWhite.setAttribute('ry', (6 * eyeScale).toFixed(2));
                this.eyeBlack.setAttribute('ry', (3 * eyeScale).toFixed(2));
            }
            
            updateTransform() {
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > 0.015) {
                    const angle = Math.atan2(this.vy, this.vx || 0.0001);
                    let delta = angle - this.turnMemory;
                    while (delta > Math.PI) delta -= Math.PI * 2;
                    while (delta < -Math.PI) delta += Math.PI * 2;
                    this.turnMemory += delta * 0.16;
                }

                const degrees = this.turnMemory * 180 / Math.PI;
                
                const maxTilt = 40;
                let displayAngle = Math.max(-maxTilt, Math.min(maxTilt, degrees));
                
                const facingRight = this.vx >= 0;
                this.element.style.left = this.x + '%';
                this.element.style.top = this.y + '%';
                
                if (facingRight) {
                    this.element.style.transform = `translate(-50%, -50%) scale(${this.size}) rotate(${displayAngle}deg)`;
                } else {
                    this.element.style.transform = `translate(-50%, -50%) scale(${-this.size}, ${this.size}) rotate(${-displayAngle}deg)`;
                }
            }
            
            scatter() {
                this.targetFood = null;
                this.behavior = 'flee';
                this.finishEvent(0.95);
                this.nextBehaviorTime = 30 + Math.random() * 50;
                const scatterForce = this.maxSpeed * (1.3 + Math.random() * 0.7);
                this.targetVx = (Math.random() - 0.5) * scatterForce * (1.3 + Math.random() * 0.4);
                this.targetVy = (Math.random() - 0.5) * scatterForce * (0.7 + Math.random() * 0.3);
            }
        }
        
        let draggedFish = null;
        let isDragging = false;
        let lastDragX = 0;
        let lastDragY = 0;
        
        // 鼠标移动
        tank.addEventListener('mousemove', (e) => {
            const rect = waterBody.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            mouseXPct = Math.max(0, Math.min(100, (mouseX / rect.width) * 100));
            mouseYPct = Math.max(0, Math.min(100, (mouseY / rect.height) * 100));
            isMouseInTank = true;
            
            cursorGlow.style.left = mouseX + 'px';
            cursorGlow.style.top = mouseY + 'px';
            
            const now = Date.now();
            if (now - lastMouseTime > 80) {
                createParticle(mouseX, mouseY);
                lastMouseTime = now;
            }
            
            if (isDragging && draggedFish) {
                const waterRect = waterBody.getBoundingClientRect();
                const x = (e.clientX - waterRect.left) / waterRect.width * 100;
                const y = (e.clientY - waterRect.top) / waterRect.height * 100;
                
                draggedFish.x = Math.max(3, Math.min(97, x));
                draggedFish.y = Math.max(8, Math.min(92, y));
                
                const vx = (draggedFish.x - lastDragX) * 80;
                const vy = (draggedFish.y - lastDragY) * 80;
                
                draggedFish.vx = vx * 0.25;
                draggedFish.vy = vy * 0.25;
                draggedFish.targetVx = vx * 0.15;
                draggedFish.targetVy = vy * 0.15;
                
                lastDragX = draggedFish.x;
                lastDragY = draggedFish.y;
            }
        });
        
        tank.addEventListener('mouseleave', () => {
            isMouseInTank = false;
            cursorGlow.style.opacity = '0';
            isDragging = false;
            draggedFish = null;
        });
        
        tank.addEventListener('mouseenter', () => {
            cursorGlow.style.opacity = '1';
        });
        
        // 点击投喂
        tank.addEventListener('click', (e) => {
            if (e.button !== 0) return;
            
            const rect = waterBody.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width * 100;
            const y = (e.clientY - rect.top) / rect.height * 100;
            
            const food = document.createElement('div');
            food.className = 'food-pellet';
            
            food.style.left = x + '%';
            food.style.top = Math.max(8, y - 4) + '%';
            foodLayer.appendChild(food);
            
            const foodObj = {
                x: x,
                y: Math.max(8, y - 4),
                element: food,
                vy: 0.11 + Math.random() * 0.08
            };
            foods.push(foodObj);
            nudgeFishToFood(foodObj, 44);
            
            const sink = () => {
                if (!document.body.contains(food)) return;
                
                foodObj.y += foodObj.vy;
                food.style.top = foodObj.y + '%';
                
                foodObj.x += Math.sin(foodObj.y * 0.07) * 0.06;
                food.style.left = foodObj.x + '%';
                
                if (foodObj.y < 88) {
                    requestAnimationFrame(sink);
                } else {
                    food.style.opacity = '0.15';
                    setTimeout(() => {
                        if (document.body.contains(food)) {
                            food.remove();
                            foods = foods.filter(f => f !== foodObj);
                        }
                    }, 6000);
                }
            };
            requestAnimationFrame(sink);
            
            const ripple = document.createElement('div');
            ripple.className = 'water-ripple';
            ripple.style.left = x + '%';
            ripple.style.top = y + '%';
            waterBody.appendChild(ripple);
            setTimeout(() => ripple.remove(), 2000);
        });
        
        // 右键拖拽
        tank.addEventListener('mousedown', (e) => {
            if (e.button !== 2) return;
            e.preventDefault();
            
            const rect = waterBody.getBoundingClientRect();
            const clickX = (e.clientX - rect.left) / rect.width * 100;
            const clickY = (e.clientY - rect.top) / rect.height * 100;
            
            for (let i = fishes.length - 1; i >= 0; i--) {
                const fish = fishes[i];
                const dx = Math.abs(fish.x - clickX);
                const dy = Math.abs(fish.y - clickY);
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if (distance < 7) {
                    draggedFish = fish;
                    isDragging = true;
                    draggedFish.element.style.filter = 'drop-shadow(0 4px 8px rgba(0,0,0,0.08)) brightness(1.1)';
                    break;
                }
            }
        });
        
        tank.addEventListener('mouseup', (e) => {
            if (isDragging && draggedFish) {
                draggedFish.element.style.filter = 'drop-shadow(0 4px 8px rgba(0,0,0,0.08))';
                draggedFish = null;
                isDragging = false;
            }
        });
        
        tank.addEventListener('contextmenu', (e) => e.preventDefault());
        
        function createParticle(x, y) {
            const particle = document.createElement('div');
            particle.className = 'cursor-particle';
            particle.style.left = x + 'px';
            particle.style.top = y + 'px';
            waterBody.appendChild(particle);
            setTimeout(() => particle.remove(), 1000);
        }

        function nudgeFishToFood(foodObj, radius = 42) {
            fishes.forEach(fish => {
                const dx = foodObj.x - fish.x;
                const dy = foodObj.y - fish.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > radius || dist < 0.01) return;
                if (!fish.shouldChaseFood(dist, true)) return;

                if (!fish.targetFood || dist < fish.targetFoodDist) {
                    fish.targetFood = foodObj;
                    fish.targetFoodDist = dist;
                }

                if (fish.behavior !== 'flee') {
                    if (fish.eventType) fish.finishEvent(0.85);
                    fish.behavior = 'hunt';
                    fish.behaviorTimer = 0;
                    fish.nextBehaviorTime = 80 + Math.random() * 70;
                }
            });
        }
        
        // 投喂功能
        function feedFish() {
            const feedCount = 3 + Math.floor(Math.random() * 3);
            const spreadWidth = 40 + Math.random() * 25;
            
            for (let i = 0; i < feedCount; i++) {
                setTimeout(() => {
                    const food = document.createElement('div');
                    food.className = 'food-pellet';
                    
                    const centerX = 50;
                    const startX = Math.max(12, Math.min(88, centerX + (Math.random() - 0.5) * spreadWidth));
                    food.style.left = startX + '%';
                    food.style.top = (8 + Math.random() * 3) + '%';
                    foodLayer.appendChild(food);
                    
                    const foodObj = {
                        x: startX,
                        y: 8 + Math.random() * 3,
                        element: food,
                        vy: 0.11 + Math.random() * 0.11
                    };
                    foods.push(foodObj);
                    nudgeFishToFood(foodObj, 46);
                    
                    const sink = () => {
                        if (!document.body.contains(food)) return;
                        
                        foodObj.y += foodObj.vy;
                        food.style.top = foodObj.y + '%';
                        
                        foodObj.x += Math.sin(foodObj.y * (0.06 + Math.random() * 0.025)) * (0.05 + Math.random() * 0.03);
                        food.style.left = foodObj.x + '%';
                        
                        if (foodObj.y < 87 + Math.random() * 3) {
                            requestAnimationFrame(sink);
                        } else {
                            food.style.opacity = (0.11 + Math.random() * 0.08).toString();
                            setTimeout(() => {
                                if (document.body.contains(food)) {
                                    food.remove();
                                    foods = foods.filter(f => f !== foodObj);
                                }
                            }, 2500 + Math.random() * 1100);
                        }
                    };
                    requestAnimationFrame(sink);
                }, i * (40 + Math.random() * 60));
            }
        }
        
        function createBubble(x, y) {
            const bubble = document.createElement('div');
            bubble.className = 'bubble';
            const size = 4 + Math.random() * 10;
            bubble.style.width = size + 'px';
            bubble.style.height = size + 'px';
            bubble.style.left = (x || (10 + Math.random() * 80)) + '%';
            bubble.style.bottom = y ? (100 - y + Math.random() * 2) + '%' : (4 + Math.random() * 15) + '%';
            bubble.style.animationDuration = (3.5 + Math.random() * 4) + 's';
            bubble.style.animationDelay = (Math.random() * 0.4) + 's';
            bubbleLayer.appendChild(bubble);
            
            setTimeout(() => {
                if (document.body.contains(bubble)) {
                    bubble.remove();
                }
            }, 7500 + Math.random() * 800);
        }
        
        function addFish() {
            const maxFishCount = 10 + Math.floor(Math.random() * 4);
            if (fishes.length < maxFishCount) {
                fishes.push(new Fish());
            }
        }
        
        function scatterFish() {
            fishes.forEach(fish => fish.scatter());
            
            const rippleCount = 2 + Math.floor(Math.random() * 2);
            for(let i = 0; i < rippleCount; i++) {
                setTimeout(() => {
                    const ripple = document.createElement('div');
                    ripple.className = 'water-ripple';
                    ripple.style.left = (18 + Math.random() * 64) + '%';
                    ripple.style.top = (25 + Math.random() * 50) + '%';
                    waterBody.appendChild(ripple);
                    setTimeout(() => ripple.remove(), 2000);
                }, i * (50 + Math.random() * 60));
            }
        }
        
        // 初始化
        function init() {
            updateSwimModeBtn();
            const initialFishCount = 5 + Math.floor(Math.random() * 3);
            for(let i = 0; i < initialFishCount; i++) {
                setTimeout(() => fishes.push(new Fish()), i * (200 + Math.random() * 200));
            }
            
            setInterval(() => createBubble(), 1600 + Math.random() * 1200);
            
            function animate() {
                fishes.forEach(fish => fish.update());
                updateCatEyes();
                requestAnimationFrame(animate);
            }
            requestAnimationFrame(animate);
        }
        
        init();
    </script>
</body>
</html>
