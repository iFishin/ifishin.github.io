<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>观鱼</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;400;500;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Noto Serif SC', serif;
            background: linear-gradient(180deg, #e8f0e5 0%, #dde8d8 50%, #d4e3ce 100%);
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            width: 100vw;
            align-items: center;
            justify-content: center;
        }
        
        /* 宣纸纹理 */
        .paper-texture {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.04;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
            pointer-events: none;
            z-index: 1;
        }
        
        /* 水墨晕染背景 */
        .ink-wash {
            position: absolute;
            border-radius: 50%;
            filter: blur(100px);
            opacity: 0.08;
            pointer-events: none;
            animation: inkFloat 25s ease-in-out infinite;
        }
        
        @keyframes inkFloat {
            0%, 100% { transform: translate(0, 0) scale(1); opacity: 0.08; }
            33% { transform: translate(20px, -15px) scale(1.05); opacity: 0.1; }
            66% { transform: translate(-15px, 20px) scale(0.98); opacity: 0.06; }
        }
        
        /* 左侧柳树 */
        .willow-left {
            position: fixed;
            left: -20px;
            top: 0;
            height: 100vh;
            width: 180px;
            z-index: 2;
            pointer-events: none;
            opacity: 0.7;
        }
        
        /* 右侧柳树 */
        .willow-right {
            position: fixed;
            right: -20px;
            top: 0;
            height: 100vh;
            width: 180px;
            z-index: 2;
            pointer-events: none;
            opacity: 0.7;
            transform: scaleX(-1);
        }
        
        .willow-branch {
            transform-origin: top center;
            animation: willowSway 4s ease-in-out infinite;
        }
        
        .willow-branch:nth-child(2) { animation-delay: -0.5s; }
        .willow-branch:nth-child(3) { animation-delay: -1s; }
        .willow-branch:nth-child(4) { animation-delay: -1.5s; }
        .willow-branch:nth-child(5) { animation-delay: -2s; }
        
        @keyframes willowSway {
            0%, 100% { transform: rotate(-2deg); }
            50% { transform: rotate(2deg); }
        }
        
        /* 标题 */
        .title {
            position: absolute;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2rem;
            color: rgba(60, 80, 60, 0.7);
            letter-spacing: 0.5em;
            font-weight: 300;
            z-index: 5;
            pointer-events: none;
            text-shadow: 0 2px 20px rgba(255,255,255,0.5);
        }
        
        /* 诗句展示 */
        .poem-container {
            position: absolute;
            top: 100px;
            right: 220px;
            writing-mode: vertical-rl;
            text-orientation: upright;
            z-index: 5;
            pointer-events: none;
            opacity: 0.6;
            transition: opacity 0.5s;
        }
        
        .poem-line {
            font-size: 0.9rem;
            color: rgba(60, 80, 60, 0.65);
            letter-spacing: 0.25em;
            line-height: 2.2;
            font-weight: 300;
        }
        
        .poem-author {
            font-size: 0.7rem;
            color: rgba(60, 80, 60, 0.5);
            margin-top: 0.8em;
            letter-spacing: 0.15em;
        }
        
        /* 鱼缸 - iOS 26风格毛玻璃 */
        .glass-tank {
            position: relative;
            width: 55vw;
            height: 50vh;
            z-index: 10;
            margin: 0 auto;
        }
        
        .glass-base {
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.25) 0%, 
                rgba(255, 255, 255, 0.1) 50%,
                rgba(255, 255, 255, 0.15) 100%);
            backdrop-filter: blur(25px) saturate(150%);
            -webkit-backdrop-filter: blur(25px) saturate(150%);
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.4);
            box-shadow: 
                /* 外阴影 - 柔和的投影 */
                0 25px 50px -12px rgba(0, 0, 0, 0.15),
                0 0 0 1px rgba(255, 255, 255, 0.2),
                /* 内发光 */
                inset 0 1px 1px rgba(255, 255, 255, 0.6),
                inset 0 -1px 1px rgba(0, 0, 0, 0.05);
        }
        
        /* 玻璃边缘高光 */
        .glass-rim {
            position: absolute;
            inset: 0;
            border-radius: 24px;
            pointer-events: none;
            box-shadow: 
                inset 0 1px 2px rgba(255, 255, 255, 0.8),
                inset 0 -1px 2px rgba(0, 0, 0, 0.03);
        }
        
        /* 水面 */
        .water-body {
            position: absolute;
            inset: 12px;
            background: linear-gradient(to bottom, 
                rgba(147, 197, 253, 0.08) 0%, 
                rgba(147, 197, 253, 0.03) 40%,
                rgba(6, 182, 212, 0.05) 100%);
            border-radius: 18px;
            overflow: hidden;
        }
        
        /* 水面微光 */
        .water-surface {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: linear-gradient(to bottom, 
                rgba(255, 255, 255, 0.15) 0%, 
                transparent 100%);
            border-radius: 18px 18px 0 0;
            pointer-events: none;
        }
        
        /* 水墨涟漪 */
        .water-ripple {
            position: absolute;
            border: 1px solid rgba(80, 100, 80, 0.25);
            border-radius: 50%;
            pointer-events: none;
            animation: inkRippleExpand 2s ease-out forwards;
        }
        
        @keyframes inkRippleExpand {
            0% { 
                width: 0; 
                height: 0; 
                opacity: 0.5;
                border-width: 1.5px;
            }
            100% { 
                width: 150px; 
                height: 150px; 
                opacity: 0;
                border-width: 0;
                margin-left: -75px;
                margin-top: -75px;
            }
        }
        
        /* 鼠标光晕 */
        .cursor-glow {
            position: absolute;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, rgba(255,255,255,0.25) 0%, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 20;
            mix-blend-mode: overlay;
        }
        
        .glass-tank:hover .cursor-glow {
            opacity: 1;
        }
        
        .cursor-particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            pointer-events: none;
            animation: particleFade 1s ease-out forwards;
        }
        
        @keyframes particleFade {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(0) translateY(-12px); opacity: 0; }
        }
        
        /* 鱼 */
        .fish {
            position: absolute;
            pointer-events: none;
            z-index: 15;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.08));
            will-change: transform;
            transition: filter 0.3s ease;
        }
        
        /* 气泡 */
        .bubble {
            position: absolute;
            background: radial-gradient(circle at 25% 25%, rgba(255, 255, 255, 0.85), rgba(255, 255, 255, 0.2));
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.35);
            animation: bubbleRise linear infinite;
            pointer-events: none;
        }
        
        @keyframes bubbleRise {
            0% { 
                transform: translateY(0) translateX(0); 
                opacity: 0; 
            }
            10% { opacity: 0.6; }
            50% { transform: translateY(-20vh) translateX(10px); }
            100% { 
                transform: translateY(-45vh) translateX(-3px); 
                opacity: 0; 
            }
        }
        
        /* 水草 */
        .seaweed {
            position: absolute;
            bottom: 0;
            transform-origin: bottom center;
            animation: seaweedSway 5s ease-in-out infinite;
        }
        
        @keyframes seaweedSway {
            0%, 100% { transform: rotate(-3deg); }
            50% { transform: rotate(3deg); }
        }
        
        /* 沙底 */
        .sand {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: linear-gradient(to top, 
                rgba(180, 160, 130, 0.15) 0%, 
                rgba(180, 160, 130, 0.06) 60%,
                transparent 100%);
            border-radius: 0 0 18px 18px;
            pointer-events: none;
        }
        
        /* 食物 */
        .food-pellet {
            position: absolute;
            width: 7px;
            height: 7px;
            background: radial-gradient(circle at 30% 30%, #fbbf24, #d97706);
            border-radius: 50%;
            box-shadow: 0 0 5px rgba(251, 191, 36, 0.4);
            pointer-events: none;
            z-index: 12;
        }
        
        /* 控制按钮 */
        .controls {
            position: absolute;
            bottom: -50px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 30;
        }
        
        .control-btn {
            padding: 10px 24px;
            background: rgba(255, 255, 255, 0.55);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 20px;
            cursor: pointer;
            font-family: 'Noto Serif SC', serif;
            color: #4a5a4a;
            font-size: 13px;
            letter-spacing: 0.15em;
            transition: all 0.3s;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.8);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
        }
        
        /* 主题切换 */
        .theme-btn {
            position: absolute;
            top: 40px;
            right: 220px;
            z-index: 50;
            background: rgba(255,255,255,0.5);
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .theme-btn:hover {
            background: rgba(255, 255, 255, 0.8);
            transform: scale(1.05);
        }
        
        .theme-menu {
            position: absolute;
            top: 85px;
            right: 220px;
            background: rgba(255,255,255,0.95);
            border-radius: 14px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            padding: 8px 0;
            min-width: 100px;
            z-index: 100;
            display: none;
        }
        
        .theme-menu.active {
            display: block;
        }
        
        .theme-option {
            padding: 8px 18px;
            font-size: 13px;
            color: #4a5a4a;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .theme-option:hover {
            background: #e8f0e5;
        }
        
        /* ========== 黑猫 ========== */
        .cat-scene {
            position: fixed;
            right: 5%;
            bottom: 8%;
            z-index: 8;
            pointer-events: none;
        }
        
        .cat-container {
            position: relative;
            width: 280px;
            height: 200px;
            pointer-events: auto;
            cursor: pointer;
        }
        
        /* 猫尾巴动画 */
        .cat-tail {
            transform-origin: 220px 140px;
            animation: catTailWag 5s ease-in-out infinite;
        }
        
        @keyframes catTailWag {
            0%, 100% { transform: rotate(-8deg); }
            25% { transform: rotate(5deg); }
            50% { transform: rotate(-3deg); }
            75% { transform: rotate(8deg); }
        }
        
        /* 猫眨眼 */
        .cat-eye {
            transform-origin: center;
            animation: catBlink 6s ease-in-out infinite;
        }
        
        @keyframes catBlink {
            0%, 48%, 52%, 100% { transform: scaleY(1); }
            50% { transform: scaleY(0.08); }
        }
        
        /* 猫耳朵 */
        .cat-ear {
            transform-origin: bottom center;
            animation: earTwitch 7s ease-in-out infinite;
        }
        
        @keyframes earTwitch {
            0%, 92%, 100% { transform: rotate(0deg); }
            94% { transform: rotate(-3deg); }
            96% { transform: rotate(2deg); }
            98% { transform: rotate(0deg); }
        }
        
        /* 猫身体呼吸 */
        .cat-body-group {
            transform-origin: 140px 130px;
            animation: catBreathe 4s ease-in-out infinite;
        }
        
        @keyframes catBreathe {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.015); }
        }
        
        /* 猫点击反应 */
        .cat-paw {
            transform-origin: 80px 150px;
            transition: transform 0.3s ease-out;
        }
        
        .cat-container.active .cat-paw {
            animation: pawReach 0.5s ease-out;
        }
        
        @keyframes pawReach {
            0% { transform: rotate(0deg); }
            30% { transform: rotate(-20deg); }
            60% { transform: rotate(-15deg); }
            100% { transform: rotate(0deg); }
        }
        
        /* 喵气泡 */
        .meow-bubble {
            position: absolute;
            top: 20px;
            right: 30px;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 16px;
            border-radius: 16px;
            font-size: 14px;
            color: #4a5a4a;
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.3s;
            pointer-events: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
        }
        
        .meow-bubble::before {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 20px;
            border-width: 8px 8px 0;
            border-style: solid;
            border-color: rgba(255, 255, 255, 0.9) transparent transparent;
        }
        
        .cat-container.active .meow-bubble {
            opacity: 1;
            transform: translateY(0);
        }
        
        /* 主题样式 */
        body.theme-sky {
            background: linear-gradient(180deg, #e0f0f5 0%, #d5e8f0 50%, #c8e0eb 100%);
        }
        
        body.theme-sky .title,
        body.theme-sky .poem-line {
            color: rgba(50, 80, 100, 0.65);
        }
        
        body.theme-sky .poem-author {
            color: rgba(50, 80, 100, 0.5);
        }
        
        body.theme-sky .control-btn {
            background: rgba(255, 255, 255, 0.6);
            color: #3a5a6a;
        }
        
        body.theme-night {
            background: linear-gradient(180deg, #1a2025 0%, #151a1f 50%, #101418 100%);
        }
        
        body.theme-night .title,
        body.theme-night .poem-line {
            color: rgba(180, 190, 180, 0.6);
        }
        
        body.theme-night .poem-author {
            color: rgba(180, 190, 180, 0.4);
        }
        
        body.theme-night .glass-base {
            background: linear-gradient(135deg, 
                rgba(40, 50, 55, 0.4) 0%, 
                rgba(30, 40, 45, 0.2) 50%,
                rgba(35, 45, 50, 0.25) 100%);
            border: 1px solid rgba(80, 90, 100, 0.3);
        }
        
        body.theme-night .control-btn {
            background: rgba(40, 50, 55, 0.6);
            color: #b0c0b0;
            border-color: rgba(80, 90, 100, 0.3);
        }
        
        /* 移动端适配 */
        @media (max-width: 1024px) {
            .glass-tank {
                width: 70vw;
                height: 55vh;
            }
            
            .cat-scene {
                right: 2%;
            }
            
            .cat-container {
                width: 200px;
                height: 140px;
            }
            
            .poem-container {
                right: 180px;
            }
            
            .theme-btn {
                right: 180px;
            }
            
            .theme-menu {
                right: 180px;
            }
        }
        
        @media (max-width: 768px) {
            html, body {
                height: 100%;
            }
            
            body {
                height: 100vh;
                padding: 0;
            }
            
            .glass-tank {
                width: 90vw;
                height: 60vh;
            }
            
            .title {
                top: 20px;
                font-size: 1.4rem;
                letter-spacing: 0.3em;
            }
            
            .poem-container,
            .theme-btn,
            .theme-menu {
                display: none;
            }
            
            .controls {
                position: fixed;
                bottom: 15px;
                left: 50%;
                transform: translateX(-50%);
                gap: 10px;
            }
            
            .control-btn {
                padding: 8px 18px;
                font-size: 12px;
            }
            
            /* 移动端隐藏猫和柳树 */
            .cat-scene,
            .willow-left,
            .willow-right {
                display: none;
            }
        }
    </style>
<base target="_blank">
</head>
<body>
    <!-- 宣纸纹理 -->
    <div class="paper-texture"></div>
    
    <!-- 水墨晕染背景 -->
    <div class="ink-wash w-[400px] h-[400px] bg-stone-500 -top-16 -left-16" style="animation-delay: 0s;"></div>
    <div class="ink-wash w-[350px] h-[350px] bg-slate-600 -bottom-12 -right-12" style="animation-delay: -8s;"></div>
    
    <!-- 左侧柳树 -->
    <svg class="willow-left" viewBox="0 0 180 800" preserveAspectRatio="xMinYMid slice">
        <!-- 主干 -->
        <path d="M80,0 Q85,200 75,400 Q70,600 80,800" stroke="rgba(60,80,60,0.3)" stroke-width="8" fill="none"/>
        <path d="M80,0 Q82,200 78,400 Q76,600 80,800" stroke="rgba(80,100,80,0.2)" stroke-width="4" fill="none"/>
        
        <!-- 柳枝1 -->
        <g class="willow-branch">
            <path d="M82,80 Q120,150 140,280 Q150,380 130,500" stroke="rgba(70,90,70,0.25)" stroke-width="2" fill="none"/>
            <path d="M140,280 Q145,320 138,360" stroke="rgba(80,110,80,0.2)" stroke-width="1" fill="none"/>
            <path d="M130,500 Q125,550 135,600" stroke="rgba(80,110,80,0.2)" stroke-width="1" fill="none"/>
        </g>
        
        <!-- 柳枝2 -->
        <g class="willow-branch">
            <path d="M78,150 Q40,250 25,400 Q15,520 35,650" stroke="rgba(70,90,70,0.25)" stroke-width="2" fill="none"/>
            <path d="M25,400 Q20,450 28,500" stroke="rgba(80,110,80,0.2)" stroke-width="1" fill="none"/>
        </g>
        
        <!-- 柳枝3 -->
        <g class="willow-branch">
            <path d="M80,250 Q110,350 120,480 Q125,580 110,700" stroke="rgba(70,90,70,0.22)" stroke-width="1.5" fill="none"/>
        </g>
        
        <!-- 柳枝4 -->
        <g class="willow-branch">
            <path d="M76,320 Q45,420 35,550 Q30,650 45,750" stroke="rgba(70,90,70,0.22)" stroke-width="1.5" fill="none"/>
        </g>
        
        <!-- 柳叶点缀 -->
        <ellipse cx="140" cy="280" rx="8" ry="3" fill="rgba(90,120,90,0.2)" transform="rotate(30 140 280)"/>
        <ellipse cx="25" cy="400" rx="8" ry="3" fill="rgba(90,120,90,0.2)" transform="rotate(-20 25 400)"/>
        <ellipse cx="120" cy="480" rx="7" ry="2.5" fill="rgba(90,120,90,0.18)" transform="rotate(25 120 480)"/>
        <ellipse cx="35" cy="550" rx="7" ry="2.5" fill="rgba(90,120,90,0.18)" transform="rotate(-25 35 550)"/>
    </svg>
    
    <!-- 右侧柳树 -->
    <svg class="willow-right" viewBox="0 0 180 800" preserveAspectRatio="xMinYMid slice">
        <path d="M80,0 Q85,200 75,400 Q70,600 80,800" stroke="rgba(60,80,60,0.3)" stroke-width="8" fill="none"/>
        <path d="M80,0 Q82,200 78,400 Q76,600 80,800" stroke="rgba(80,100,80,0.2)" stroke-width="4" fill="none"/>
        
        <g class="willow-branch">
            <path d="M82,80 Q120,150 140,280 Q150,380 130,500" stroke="rgba(70,90,70,0.25)" stroke-width="2" fill="none"/>
            <path d="M140,280 Q145,320 138,360" stroke="rgba(80,110,80,0.2)" stroke-width="1" fill="none"/>
            <path d="M130,500 Q125,550 135,600" stroke="rgba(80,110,80,0.2)" stroke-width="1" fill="none"/>
        </g>
        
        <g class="willow-branch">
            <path d="M78,150 Q40,250 25,400 Q15,520 35,650" stroke="rgba(70,90,70,0.25)" stroke-width="2" fill="none"/>
            <path d="M25,400 Q20,450 28,500" stroke="rgba(80,110,80,0.2)" stroke-width="1" fill="none"/>
        </g>
        
        <g class="willow-branch">
            <path d="M80,250 Q110,350 120,480 Q125,580 110,700" stroke="rgba(70,90,70,0.22)" stroke-width="1.5" fill="none"/>
        </g>
        
        <g class="willow-branch">
            <path d="M76,320 Q45,420 35,550 Q30,650 45,750" stroke="rgba(70,90,70,0.22)" stroke-width="1.5" fill="none"/>
        </g>
        
        <ellipse cx="140" cy="280" rx="8" ry="3" fill="rgba(90,120,90,0.2)" transform="rotate(30 140 280)"/>
        <ellipse cx="25" cy="400" rx="8" ry="3" fill="rgba(90,120,90,0.2)" transform="rotate(-20 25 400)"/>
        <ellipse cx="120" cy="480" rx="7" ry="2.5" fill="rgba(90,120,90,0.18)" transform="rotate(25 120 480)"/>
        <ellipse cx="35" cy="550" rx="7" ry="2.5" fill="rgba(90,120,90,0.18)" transform="rotate(-25 35 550)"/>
    </svg>
    
    <!-- 标题 -->
    <div class="title">观鱼</div>
    
    <!-- 诗句展示 -->
    <div class="poem-container" id="poemContainer">
        <div class="poem-line" id="poemLine1">鱼戏莲叶间</div>
        <div class="poem-line" id="poemLine2">鱼戏莲叶东</div>
        <div class="poem-author" id="poemAuthor">—— 汉乐府</div>
    </div>
    
    <!-- 主题切换 -->
    <div class="theme-btn" id="themeBtn" title="切换主题">
        <svg width="20" height="20" fill="none" viewBox="0 0 24 24">
            <path d="M12 3v2m0 14v2m9-9h-2M5 12H3m15.364-6.364l-1.414 1.414M6.05 17.95l-1.414 1.414m12.728 0l-1.414-1.414M6.05 6.05L4.636 4.636" stroke="#4a5a4a" stroke-width="1.5" stroke-linecap="round"/>
        </svg>
    </div>
    <div class="theme-menu" id="themeMenu">
        <div class="theme-option" data-theme="">春绿</div>
        <div class="theme-option" data-theme="sky">晴空</div>
        <div class="theme-option" data-theme="night">夜色</div>
    </div>
    
    <!-- 鱼缸 -->
    <div class="glass-tank" id="tank">
        <div class="glass-base"></div>
        <div class="glass-rim"></div>
        <div class="water-body">
            <div class="water-surface"></div>
            <div class="cursor-glow" id="cursorGlow"></div>
            
            <!-- 水草 -->
            <svg class="seaweed left-[8%] w-20 h-36 text-emerald-700/25" viewBox="0 0 100 200" style="animation-delay: 0s;">
                <path d="M50,200 Q18,145 50,95 T48,5" stroke="currentColor" stroke-width="3" fill="none" opacity="0.6"/>
                <path d="M50,200 Q82,155 50,105 T52,25" stroke="currentColor" stroke-width="2" fill="none" opacity="0.4"/>
            </svg>
            <svg class="seaweed left-[22%] w-14 h-28 text-teal-700/20" viewBox="0 0 100 200" style="animation-delay: -2s;">
                <path d="M50,200 Q28,145 50,85 T52,15" stroke="currentColor" stroke-width="2" fill="none" opacity="0.5"/>
            </svg>
            <svg class="seaweed right-[10%] w-24 h-44 text-emerald-800/30" viewBox="0 0 100 200" style="animation-delay: -4s;">
                <path d="M50,200 Q12,165 50,115 T48,5" stroke="currentColor" stroke-width="4" fill="none" opacity="0.6"/>
                <path d="M50,200 Q88,145 50,95 T52,35" stroke="currentColor" stroke-width="2" fill="none" opacity="0.4"/>
            </svg>
            <svg class="seaweed right-[28%] w-12 h-28 text-cyan-800/18" viewBox="0 0 100 200" style="animation-delay: -1s;">
                <path d="M50,200 Q32,155 50,105 T50,25" stroke="currentColor" stroke-width="2" fill="none" opacity="0.4"/>
            </svg>
            
            <!-- 沙底 -->
            <div class="sand"></div>
            
            <!-- 鱼层 -->
            <div id="fishLayer"></div>
            <!-- 食物层 -->
            <div id="foodLayer"></div>
            <!-- 气泡层 -->
            <div id="bubbleLayer"></div>
        </div>
        
        <!-- 控制按钮 -->
        <div class="controls">
            <button class="control-btn" onclick="addFish()">添鱼</button>
            <button class="control-btn" onclick="feedFish()">投喂</button>
            <button class="control-btn" onclick="scatterFish()">惊扰</button>
        </div>
    </div>
    
    <!-- 黑猫 - 侧向盯着鱼缸 -->
    <div class="cat-scene" id="catScene">
        <div class="cat-container" id="catContainer">
            <div class="meow-bubble">喵~</div>
            <svg viewBox="0 0 280 200" width="280" height="200">
                <!-- 猫尾巴 -->
                <path class="cat-tail" d="M220,130 Q250,110 255,80 Q260,50 245,35 Q235,30 230,45 Q225,65 235,85 Q242,105 220,130" 
                      fill="#1a1a1a" opacity="0.95"/>
                
                <!-- 后腿 -->
                <ellipse cx="200" cy="155" rx="22" ry="28" fill="#1a1a1a"/>
                <ellipse cx="200" cy="175" rx="18" ry="8" fill="#0a0a0a"/>
                
                <!-- 身体组 -->
                <g class="cat-body-group">
                    <!-- 身体主体 -->
                    <ellipse cx="140" cy="140" rx="65" ry="40" fill="#1a1a1a"/>
                    
                    <!-- 前腿（蹲坐姿势） -->
                    <ellipse cx="95" cy="165" rx="18" ry="25" fill="#1a1a1a"/>
                    <ellipse cx="125" cy="168" rx="16" ry="22" fill="#1a1a1a"/>
                    
                    <!-- 爪子 -->
                    <ellipse class="cat-paw" cx="82" cy="185" rx="14" ry="10" fill="#0a0a0a"/>
                    <ellipse cx="112" cy="188" rx="12" ry="9" fill="#0a0a0a"/>
                </g>
                
                <!-- 猫头组 - 侧向看鱼缸 -->
                <g class="cat-head-group">
                    <!-- 左耳（后侧） -->
                    <path class="cat-ear" d="M55,65 L45,35 L75,50 Z" fill="#1a1a1a"/>
                    <path d="M58,60 L52,42 L68,52 Z" fill="#3a2a2a" opacity="0.6"/>
                    
                    <!-- 头部轮廓 -->
                    <ellipse cx="85" cy="85" rx="45" ry="38" fill="#1a1a1a"/>
                    
                    <!-- 右耳（前侧，更突出） -->
                    <path class="cat-ear" d="M105,55 L118,22 L130,58 Z" fill="#1a1a1a"/>
                    <path d="M112,52 L118,32 L124,54 Z" fill="#3a2a2a" opacity="0.6"/>
                    
                    <!-- 眼睛（侧视，盯着左边鱼缸方向） -->
                    <g class="cat-eye">
                        <!-- 左眼（较远） -->
                        <ellipse cx="65" cy="78" rx="10" ry="12" fill="#f5d547"/>
                        <ellipse cx="68" cy="78" rx="4" ry="8" fill="#000"/>
                        <circle cx="70" cy="75" r="2.5" fill="#fff" opacity="0.8"/>
                    </g>
                    <g class="cat-eye">
                        <!-- 右眼（较近，更大更亮） -->
                        <ellipse cx="95" cy="80" rx="12" ry="14" fill="#f5d547"/>
                        <ellipse cx="99" cy="80" rx="5" ry="9" fill="#000"/>
                        <circle cx="102" cy="76" r="3" fill="#fff" opacity="0.9"/>
                    </g>
                    
                    <!-- 鼻子 -->
                    <path d="M48,95 L44,100 L52,100 Z" fill="#d4a4a4"/>
                    
                    <!-- 嘴巴（侧面） -->
                    <path d="M48,100 Q40,105 38,102" stroke="#888" stroke-width="1" fill="none"/>
                    <path d="M48,100 Q42,108 45,112" stroke="#888" stroke-width="1" fill="none"/>
                    
                    <!-- 胡须 -->
                    <line x1="35" y1="88" x2="8" y2="82" stroke="#666" stroke-width="0.8" opacity="0.5"/>
                    <line x1="35" y1="95" x2="5" y2="95" stroke="#666" stroke-width="0.8" opacity="0.5"/>
                    <line x1="35" y1="102" x2="8" y2="108" stroke="#666" stroke-width="0.8" opacity="0.5"/>
                    
                    <!-- 脸部轮廓线（增加立体感） -->
                    <path d="M48,65 Q35,75 38,95" stroke="#2a2a2a" stroke-width="1" fill="none" opacity="0.5"/>
                </g>
            </svg>
        </div>
    </div>

    <script>
        // ========== 主题切换 ==========
        const themeBtn = document.getElementById('themeBtn');
        const themeMenu = document.getElementById('themeMenu');
        const themeOptions = themeMenu.querySelectorAll('.theme-option');
        
        function setTheme(theme) {
            document.body.classList.remove('theme-sky', 'theme-night');
            if (theme) {
                document.body.classList.add('theme-' + theme);
            }
            localStorage.setItem('guanyu-theme', theme);
        }
        
        const savedTheme = localStorage.getItem('guanyu-theme') || '';
        setTheme(savedTheme);
        
        themeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            themeMenu.classList.toggle('active');
        });
        
        themeOptions.forEach(opt => {
            opt.addEventListener('click', () => {
                setTheme(opt.dataset.theme);
                themeMenu.classList.remove('active');
            });
        });
        
        document.addEventListener('click', (e) => {
            if (!themeBtn.contains(e.target) && !themeMenu.contains(e.target)) {
                themeMenu.classList.remove('active');
            }
        });
        
        // ========== 诗句轮播 ==========
        const poems = [
            { line1: '鱼戏莲叶间', line2: '鱼戏莲叶东', author: '汉乐府' },
            { line1: '潭清疑水浅', line2: '荷动知鱼散', author: '储光羲' },
            { line1: '细雨鱼儿出', line2: '微风燕子斜', author: '杜甫' },
            { line1: '观鱼碧潭上', line2: '木落潭水清', author: '李白' },
            { line1: '鱼跃此时海', line2: '花开彼岸天', author: '佚名' },
            { line1: '临池观鱼戏', line2: '悠然忘世机', author: '白居易' }
        ];
        
        let currentPoemIndex = 0;
        function rotatePoem() {
            currentPoemIndex = (currentPoemIndex + 1) % poems.length;
            const poem = poems[currentPoemIndex];
            const container = document.getElementById('poemContainer');
            
            container.style.opacity = '0';
            setTimeout(() => {
                document.getElementById('poemLine1').textContent = poem.line1;
                document.getElementById('poemLine2').textContent = poem.line2;
                document.getElementById('poemAuthor').textContent = '—— ' + poem.author;
                container.style.opacity = '0.6';
            }, 500);
        }
        
        setInterval(rotatePoem, 15000);
        
        // ========== 黑猫互动 ==========
        const catContainer = document.getElementById('catContainer');
        const catEyes = document.querySelectorAll('.cat-eye ellipse:nth-child(2)');
        
        // 猫眼睛跟随鱼
        function updateCatEyes() {
            if (window.innerWidth <= 768 || fishes.length === 0) return;
            
            // 找到最接近鱼缸左侧的鱼（猫盯着的方向）
            let targetFish = null;
            let minX = Infinity;
            
            fishes.forEach(fish => {
                if (fish.x < minX) {
                    minX = fish.x;
                    targetFish = fish;
                }
            });
            
            if (targetFish) {
                // 根据鱼的垂直位置调整眼睛
                const eyeOffset = targetFish.y > 50 ? 1.5 : targetFish.y < 30 ? -1.5 : 0;
                
                catEyes.forEach(eye => {
                    eye.style.transform = `translateY(${eyeOffset}px)`;
                });
            }
        }
        
        // 点击猫
        catContainer.addEventListener('click', () => {
            catContainer.classList.add('active');
            playMeowSound();
            
            setTimeout(() => {
                catContainer.classList.remove('active');
            }, 1500);
        });
        
        // 喵声音效
        function playMeowSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(380, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(580, audioContext.currentTime + 0.08);
                oscillator.frequency.exponentialRampToValueAtTime(280, audioContext.currentTime + 0.25);
                
                gainNode.gain.setValueAtTime(0.08, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.25);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.25);
            } catch (e) {}
        }
        
        // ========== 鱼缸相关 ==========
        const tank = document.getElementById('tank');
        const waterBody = tank.querySelector('.water-body');
        const fishLayer = document.getElementById('fishLayer');
        const foodLayer = document.getElementById('foodLayer');
        const bubbleLayer = document.getElementById('bubbleLayer');
        const cursorGlow = document.getElementById('cursorGlow');
        
        let fishes = [];
        let foods = [];
        let mouseX = 0, mouseY = 0;
        let isMouseInTank = false;
        let lastMouseTime = 0;
        
        const fishColors = [
            { body: '#3b82f6', tail: '#1e3a8a', name: '蓝' },
            { body: '#10b981', tail: '#064e3b', name: '翠' },
            { body: '#64748b', tail: '#0f172a', name: '墨' },
            { body: '#06b6d4', tail: '#164e63', name: '青' },
            { body: '#8b5cf6', tail: '#4c1d95', name: '紫' },
            { body: '#f59e0b', tail: '#78350f', name: '金' }
        ];
        
        class Fish {
            constructor(x, y) {
                this.x = x || (15 + Math.random() * 70);
                this.y = y || (20 + Math.random() * 55);
                this.vx = (Math.random() - 0.5) * (0.7 + Math.random() * 0.4);
                this.vy = (Math.random() - 0.5) * (0.2 + Math.random() * 0.2);
                this.targetVx = this.vx;
                this.targetVy = this.vy;
                this.maxSpeed = 2 + Math.random() * 0.6;
                this.normalSpeed = 0.6 + Math.random() * 0.3;
                this.dragCoeff = 0.94 + Math.random() * 0.03;
                this.size = 0.7 + Math.random() * 0.3;
                this.baseSize = this.size;
                this.colorIndex = Math.floor(Math.random() * fishColors.length);
                this.color = fishColors[this.colorIndex];
                this.eatCount = 0;
                this.growthStage = 0;
                this.behavior = 'wander';
                this.behaviorTimer = 0;
                this.nextBehaviorTime = 45 + Math.random() * 120;
                this.targetFood = null;
                this.targetFoodDist = Infinity;
                this.avoidForce = { x: 0, y: 0 };
                this.tailPhase = Math.random() * Math.PI * 2;
                this.bodyPhase = Math.random() * Math.PI * 2;
                this.eyeBlinkTimer = 0;
                this.eyeBlinkDuration = 0;
                this.nextBlinkTime = 55 + Math.random() * 150;
                this.isBlinking = false;
                this.element = this.createSVGElement();
            }
            
            createSVGElement() {
                const div = document.createElement('div');
                div.className = 'fish';
                div.style.width = '80px';
                div.style.height = '40px';
                
                const svgNS = "http://www.w3.org/2000/svg";
                const svg = document.createElementNS(svgNS, 'svg');
                svg.setAttribute('viewBox', '0 0 120 60');
                svg.style.overflow = 'visible';
                
                const defs = document.createElementNS(svgNS, 'defs');
                const gradId = `grad-${this.color.name}-${Math.floor(Math.random()*1000)}`;
                defs.innerHTML = `
                    <linearGradient id="${gradId}" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:${this.color.tail}" />
                        <stop offset="50%" style="stop-color:${this.color.body}" />
                        <stop offset="100%" style="stop-color:${this.color.body}" />
                    </linearGradient>
                `;
                svg.appendChild(defs);
                
                const tail = document.createElementNS(svgNS, 'path');
                tail.setAttribute('d', 'M 10,30 Q -5,15 2,30 Q -8,45 10,30 Z');
                tail.setAttribute('fill', this.color.tail);
                tail.style.transformOrigin = '10px 30px';
                this.tailElement = tail;
                svg.appendChild(tail);
                
                const dorsal = document.createElementNS(svgNS, 'path');
                dorsal.setAttribute('d', 'M 35,14 Q 50,2 70,14 L 65,25 Q 50,18 40,25 Z');
                dorsal.setAttribute('fill', this.color.tail);
                dorsal.setAttribute('opacity', '0.8');
                dorsal.style.transformOrigin = '52px 20px';
                this.dorsalElement = dorsal;
                svg.appendChild(dorsal);
                
                const pectoralLeft = document.createElementNS(svgNS, 'path');
                pectoralLeft.setAttribute('d', 'M 45,38 Q 35,42 38,52');
                pectoralLeft.setAttribute('stroke', this.color.tail);
                pectoralLeft.setAttribute('stroke-width', '2');
                pectoralLeft.setAttribute('fill', 'none');
                pectoralLeft.setAttribute('opacity', '0.6');
                pectoralLeft.style.transformOrigin = '45px 38px';
                this.pectoralLeftElement = pectoralLeft;
                svg.appendChild(pectoralLeft);
                
                const pectoralRight = document.createElementNS(svgNS, 'path');
                pectoralRight.setAttribute('d', 'M 45,22 Q 35,18 38,8');
                pectoralRight.setAttribute('stroke', this.color.tail);
                pectoralRight.setAttribute('stroke-width', '2');
                pectoralRight.setAttribute('fill', 'none');
                pectoralRight.setAttribute('opacity', '0.6');
                pectoralRight.style.transformOrigin = '45px 22px';
                this.pectoralRightElement = pectoralRight;
                svg.appendChild(pectoralRight);
                
                const body = document.createElementNS(svgNS, 'ellipse');
                body.setAttribute('cx', '62');
                body.setAttribute('cy', '30');
                body.setAttribute('rx', '42');
                body.setAttribute('ry', '24');
                body.setAttribute('fill', `url(#${gradId})`);
                this.bodyElement = body;
                svg.appendChild(body);
                
                const scales = document.createElementNS(svgNS, 'g');
                scales.setAttribute('opacity', '0.1');
                for(let i=0; i<4; i++) {
                    for(let j=0; j<2; j++) {
                        const path = document.createElementNS(svgNS, 'path');
                        path.setAttribute('d', `M ${40+i*10},${20+j*14} Q ${45+i*10},${27+j*14} ${40+i*10},${34+j*14}`);
                        path.setAttribute('stroke', 'white');
                        path.setAttribute('fill', 'none');
                        scales.appendChild(path);
                    }
                }
                svg.appendChild(scales);
                
                const eyeGroup = document.createElementNS(svgNS, 'g');
                this.eyeGroup = eyeGroup;
                
                const eyeWhite = document.createElementNS(svgNS, 'circle');
                eyeWhite.setAttribute('cx', '92');
                eyeWhite.setAttribute('cy', '20');
                eyeWhite.setAttribute('r', '6');
                eyeWhite.setAttribute('fill', 'white');
                this.eyeWhite = eyeWhite;
                
                const eyeBlack = document.createElementNS(svgNS, 'circle');
                eyeBlack.setAttribute('cx', '94');
                eyeBlack.setAttribute('cy', '20');
                eyeBlack.setAttribute('r', '3');
                eyeBlack.setAttribute('fill', '#0f172a');
                this.eyeBlack = eyeBlack;
                
                const eyeShine = document.createElementNS(svgNS, 'circle');
                eyeShine.setAttribute('cx', '95');
                eyeShine.setAttribute('cy', '19');
                eyeShine.setAttribute('r', '1.5');
                eyeShine.setAttribute('fill', 'white');
                
                eyeGroup.appendChild(eyeWhite);
                eyeGroup.appendChild(eyeBlack);
                eyeGroup.appendChild(eyeShine);
                svg.appendChild(eyeGroup);
                
                const mouth = document.createElementNS(svgNS, 'path');
                mouth.setAttribute('d', 'M 105,32 Q 108,30 105,28');
                mouth.setAttribute('stroke', '#0f172a');
                mouth.setAttribute('stroke-width', '1.5');
                mouth.setAttribute('fill', 'none');
                mouth.setAttribute('opacity', '0.4');
                this.mouthElement = mouth;
                svg.appendChild(mouth);
                
                div.appendChild(svg);
                fishLayer.appendChild(div);
                return div;
            }
            
            update() {
                this.behaviorTimer++;
                if (this.behaviorTimer >= this.nextBehaviorTime) {
                    this.chooseBehavior();
                    this.behaviorTimer = 0;
                }
                
                if (foods.length > 0 && this.behaviorTimer % 3 === 0 && !this.targetFood) {
                    this.findNearestFood();
                }
                
                if (foods.length > 0 && this.behaviorTimer % 15 === 0) {
                    this.tryRandomFoodHunt();
                }
                
                if (this.targetFood && !document.body.contains(this.targetFood.element)) {
                    this.targetFood = null;
                }
                
                if (this.behavior === 'wander' && Math.random() < 0.03) {
                    this.targetVy += (Math.random() - 0.5) * 0.4;
                }
                
                if (Math.random() < 0.007) {
                    this.targetVx += (Math.random() - 0.5) * 1;
                    this.targetVy += (Math.random() - 0.5) * 1;
                }
                
                switch(this.behavior) {
                    case 'wander':
                        this.wanderBehavior();
                        break;
                    case 'hunt':
                        this.huntBehavior();
                        break;
                    case 'flee':
                        this.fleeBehavior();
                        break;
                    case 'rest':
                        this.restBehavior();
                        break;
                }
                
                if (this.behaviorTimer % 5 === 0) {
                    this.updateAvoidance();
                } else {
                    this.avoidForce.x *= 0.9;
                    this.avoidForce.y *= 0.9;
                }
                
                this.targetVx += this.avoidForce.x;
                this.targetVy += this.avoidForce.y;
                
                let vyBoost = 1;
                if (this.targetVy > 0.2) vyBoost = 1.2;
                
                let targetSpeed = Math.sqrt(this.targetVx * this.targetVx + this.targetVy * this.targetVy);
                if (targetSpeed > this.maxSpeed * vyBoost) {
                    this.targetVx = (this.targetVx / targetSpeed) * this.maxSpeed * vyBoost;
                    this.targetVy = (this.targetVy / targetSpeed) * this.maxSpeed * vyBoost;
                }
                
                this.vx += (this.targetVx - this.vx) * 0.08;
                this.vy += (this.targetVy - this.vy) * 0.08;
                
                this.vx *= this.dragCoeff;
                this.vy *= this.dragCoeff;
                
                this.handleBoundaries();
                
                this.x += this.vx * 0.1;
                this.y += this.vy * 0.1;
                
                this.x = Math.max(3, Math.min(97, this.x));
                this.y = Math.max(8, Math.min(92, this.y));
                
                this.updateAnimation();
                this.updateTransform();
            }
            
            findNearestFood() {
                let nearest = null;
                let minDist = Infinity;
                const searchRadius = 24 + Math.random() * 12;
                
                for (let i = 0; i < foods.length; i++) {
                    const food = foods[i];
                    const isFoodTaken = fishes.some(f => f.targetFood === food && f !== this);
                    
                    const dx = food.x - this.x;
                    const dy = food.y - this.y;
                    const dist = dx*dx + dy*dy;
                    
                    const effectiveRadius = isFoodTaken ? searchRadius * 0.5 : searchRadius;
                    
                    if (dist < minDist && dist < effectiveRadius * effectiveRadius) {
                        minDist = dist;
                        nearest = food;
                    }
                }
                
                if (nearest) {
                    this.targetFood = nearest;
                    this.targetFoodDist = Math.sqrt(minDist);
                }
            }
            
            tryRandomFoodHunt() {
                if (foods.length === 0 || Math.random() > 0.1) return;
                
                const randomFood = foods[Math.floor(Math.random() * foods.length)];
                const dx = randomFood.x - this.x;
                const dy = randomFood.y - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < 35 + Math.random() * 15) {
                    this.targetFood = randomFood;
                    this.targetFoodDist = dist;
                    this.behavior = 'hunt';
                    this.nextBehaviorTime = 140 + Math.random() * 80;
                }
            }
            
            updateAvoidance() {
                this.avoidForce.x = 0;
                this.avoidForce.y = 0;
                
                const avoidRadius = 10 + Math.random() * 4;
                const avoidRadiusSq = avoidRadius * avoidRadius;
                
                for (let i = 0; i < fishes.length; i++) {
                    const other = fishes[i];
                    if (other === this) continue;
                    
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const distSq = dx*dx + dy*dy;
                    
                    if (distSq < avoidRadiusSq && distSq > 0.1) {
                        const dist = Math.sqrt(distSq);
                        const force = (avoidRadius - dist) / avoidRadius;
                        const forceStrengthX = 0.1 + Math.random() * 0.06;
                        const forceStrengthY = 0.08 + Math.random() * 0.04;
                        this.avoidForce.x -= (dx / dist) * force * forceStrengthX;
                        this.avoidForce.y -= (dy / dist) * force * forceStrengthY;
                    }
                }
            }
            
            handleBoundaries() {
                const hardMargin = 2;
                const softMargin = 10;
                
                let needsTurn = false;
                
                if (this.x < softMargin) {
                    needsTurn = true;
                    this.targetVx = Math.abs(this.targetVx) + (Math.random() - 0.5) * 0.2;
                } else if (this.x > 100 - softMargin) {
                    needsTurn = true;
                    this.targetVx = -Math.abs(this.targetVx) - (Math.random() - 0.5) * 0.2;
                }
                
                if (this.y < softMargin) {
                    needsTurn = true;
                    this.targetVy = Math.abs(this.targetVy) + (Math.random() - 0.5) * 0.15;
                } else if (this.y > 95 - softMargin) {
                    needsTurn = true;
                    this.targetVy = -Math.abs(this.targetVy) - (Math.random() - 0.5) * 0.15;
                }
                
                if (needsTurn && (this.behavior !== 'flee' && this.behavior !== 'hunt')) {
                    this.behavior = 'flee';
                    this.nextBehaviorTime = 25 + Math.random() * 30;
                }
                
                if (this.x < hardMargin) {
                    this.x = hardMargin;
                    this.vx = Math.abs(this.vx) * 0.5;
                } else if (this.x > 100 - hardMargin) {
                    this.x = 100 - hardMargin;
                    this.vx = -Math.abs(this.vx) * 0.5;
                }
                
                if (this.y < hardMargin) {
                    this.y = hardMargin;
                    this.vy = Math.abs(this.vy) * 0.5;
                } else if (this.y > 95 - hardMargin) {
                    this.y = 95 - hardMargin;
                    this.vy = -Math.abs(this.vy) * 0.5;
                }
            }
            
            chooseBehavior() {
                if (this.targetFood && this.targetFoodDist < 24 + Math.random() * 6) {
                    this.behavior = 'hunt';
                    this.nextBehaviorTime = 120 + Math.random() * 100;
                } else {
                    const rand = Math.random();
                    if (rand < 0.5 + Math.random() * 0.1) {
                        this.behavior = 'wander';
                        this.nextBehaviorTime = 50 + Math.random() * 130;
                    } else if (rand < 0.8 + Math.random() * 0.1) {
                        this.behavior = 'rest';
                        this.nextBehaviorTime = 25 + Math.random() * 80;
                    } else {
                        this.behavior = 'flee';
                        this.nextBehaviorTime = 15 + Math.random() * 50;
                    }
                }
            }
            
            wanderBehavior() {
                const changeFreq = 12 + Math.random() * 20;
                if (this.behaviorTimer % changeFreq === 0) {
                    const angleVariation = (Math.random() - 0.5) * (0.25 + Math.random() * 0.25);
                    const currentAngle = Math.atan2(this.vy, this.vx);
                    const newAngle = currentAngle + angleVariation;
                    
                    const speed = Math.sqrt(this.targetVx * this.targetVx + this.targetVy * this.targetVy);
                    const newSpeed = Math.max(
                        0.25 + Math.random() * 0.15, 
                        Math.min(this.normalSpeed + Math.random() * 0.25, speed + (Math.random() - 0.5) * 0.32)
                    );
                    
                    this.targetVx = Math.cos(newAngle) * newSpeed;
                    this.targetVy = Math.sin(newAngle) * newSpeed;
                }
            }
            
            huntBehavior() {
                if (!this.targetFood) {
                    this.behavior = 'wander';
                    return;
                }
                const dx = this.targetFood.x - this.x;
                const dy = this.targetFood.y - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const eatDistance = 2 + Math.random() * 0.8;
                
                if (dist < eatDistance) {
                    this.targetFood.element.remove();
                    foods = foods.filter(f => f !== this.targetFood);
                    this.targetFood = null;
                    
                    this.eatCount = (this.eatCount || 0) + 1;
                    
                    if (this.eatCount < 5) {
                        this.size = Math.min(this.size * (1.03 + Math.random() * 0.008), this.baseSize * 1.12);
                        this.growthStage = 0;
                    } else if (this.eatCount < 12) {
                        this.size = Math.min(this.size * (1.018 + Math.random() * 0.008), this.baseSize * 1.28);
                        this.growthStage = 1;
                    } else {
                        if (this.growthStage < 2) {
                            this.colorIndex = (this.colorIndex + 1) % fishColors.length;
                            this.color = fishColors[this.colorIndex];
                            this.updateColor();
                            this.element.style.filter = 'drop-shadow(0 0 12px #fbbf24) brightness(1.1)';
                            setTimeout(() => {
                                this.element.style.filter = 'drop-shadow(0 4px 8px rgba(0,0,0,0.08))';
                            }, 600);
                        }
                        this.size = Math.min(this.size * (1.006 + Math.random() * 0.008), this.baseSize * 1.4);
                        this.growthStage = 2;
                    }
                    
                    createBubble(this.x, this.y);
                    this.behavior = 'rest';
                    this.nextBehaviorTime = 20 + Math.random() * 40;
                } else {
                    const targetAngle = Math.atan2(dy, dx);
                    const huntSpeed = this.maxSpeed * (0.68 + Math.random() * 0.16);
                    this.targetVx = Math.cos(targetAngle) * huntSpeed;
                    this.targetVy = Math.sin(targetAngle) * huntSpeed * (0.5 + Math.random() * 0.16);
                }
            }
            
            updateColor() {
                const svg = this.element.querySelector('svg');
                const grad = svg.querySelector('linearGradient');
                grad.innerHTML = `
                    <stop offset="0%" style="stop-color:${this.color.tail}" />
                    <stop offset="50%" style="stop-color:${this.color.body}" />
                    <stop offset="100%" style="stop-color:${this.color.body}" />
                `;
                this.tailElement.setAttribute('fill', this.color.tail);
                this.dorsalElement.setAttribute('fill', this.color.tail);
                this.pectoralLeftElement.setAttribute('stroke', this.color.tail);
                this.pectoralRightElement.setAttribute('stroke', this.color.tail);
                this.bodyElement.setAttribute('fill', `url(#${grad.id})`);
            }
            
            restBehavior() {
                const decelFactor = 0.88 + Math.random() * 0.04;
                this.targetVx *= decelFactor;
                this.targetVy *= decelFactor;
            }
            
            fleeBehavior() {
                if (this.behaviorTimer === 0) {
                    const angle = (Math.random() - 0.5) * Math.PI * (0.75 + Math.random() * 0.4);
                    const fleeSpeed = this.maxSpeed * (0.68 + Math.random() * 0.25);
                    this.targetVx = Math.cos(angle) * fleeSpeed;
                    this.targetVy = Math.sin(angle) * fleeSpeed * (0.45 + Math.random() * 0.25);
                }
            }
            
            updateAnimation() {
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                
                this.tailPhase += (0.08 + Math.random() * 0.03) + speed * (0.06 + Math.random() * 0.03);
                const tailAngle = Math.sin(this.tailPhase) * (6 + speed * (4 + Math.random() * 1.5));
                this.tailElement.style.transform = `rotate(${tailAngle}deg)`;
                
                this.bodyPhase += 0.012 + Math.random() * 0.006;
                const breath = 1 + Math.sin(this.bodyPhase) * (0.012 + Math.random() * 0.008);
                this.bodyElement.style.transform = `scale(${breath})`;
                
                const dorsalAngle = Math.sin(this.tailPhase * (0.4 + Math.random() * 0.08)) * (4 + Math.random() * 1.5);
                this.dorsalElement.style.transform = `rotate(${dorsalAngle}deg)`;
                
                const pectoralAngle = Math.sin(this.bodyPhase + speed) * (10 + speed * 3 + Math.random() * 4);
                this.pectoralLeftElement.style.transform = `rotate(${pectoralAngle}deg)`;
                this.pectoralRightElement.style.transform = `rotate(${-pectoralAngle}deg)`;
                
                this.eyeBlinkTimer++;
                
                if (this.eyeBlinkTimer >= this.nextBlinkTime) {
                    this.isBlinking = true;
                    this.eyeBlinkDuration = 0;
                    this.eyeBlinkTimer = 0;
                    this.nextBlinkTime = 60 + Math.random() * 160;
                }
                
                let eyeScale = 1;
                
                if (this.isBlinking) {
                    this.eyeBlinkDuration++;
                    const blinkDuration = 8 + Math.random() * 3;
                    
                    if (this.eyeBlinkDuration < blinkDuration / 2) {
                        eyeScale = 1 - (this.eyeBlinkDuration / (blinkDuration / 2));
                    } else if (this.eyeBlinkDuration < blinkDuration) {
                        eyeScale = (this.eyeBlinkDuration - blinkDuration / 2) / (blinkDuration / 2);
                    } else {
                        this.isBlinking = false;
                        eyeScale = 1;
                    }
                }
                
                this.eyeWhite.setAttribute('ry', 6 * eyeScale);
                this.eyeBlack.setAttribute('r', 3 * eyeScale);
            }
            
            updateTransform() {
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed < 0.04) return;
                
                const angle = Math.atan2(this.vy, this.vx);
                const degrees = angle * 180 / Math.PI;
                
                const maxTilt = 40;
                let displayAngle = Math.max(-maxTilt, Math.min(maxTilt, degrees));
                
                const facingRight = this.vx >= 0;
                this.element.style.left = this.x + '%';
                this.element.style.top = this.y + '%';
                
                if (facingRight) {
                    this.element.style.transform = `translate(-50%, -50%) scale(${this.size}) rotate(${displayAngle}deg)`;
                } else {
                    this.element.style.transform = `translate(-50%, -50%) scale(${-this.size}, ${this.size}) rotate(${-displayAngle}deg)`;
                }
            }
            
            scatter() {
                this.targetFood = null;
                this.behavior = 'flee';
                this.nextBehaviorTime = 30 + Math.random() * 50;
                const scatterForce = this.maxSpeed * (1.3 + Math.random() * 0.7);
                this.targetVx = (Math.random() - 0.5) * scatterForce * (1.3 + Math.random() * 0.4);
                this.targetVy = (Math.random() - 0.5) * scatterForce * (0.7 + Math.random() * 0.3);
            }
        }
        
        let draggedFish = null;
        let isDragging = false;
        let lastDragX = 0;
        let lastDragY = 0;
        
        // 鼠标移动
        tank.addEventListener('mousemove', (e) => {
            const rect = waterBody.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            isMouseInTank = true;
            
            cursorGlow.style.left = mouseX + 'px';
            cursorGlow.style.top = mouseY + 'px';
            
            const now = Date.now();
            if (now - lastMouseTime > 80) {
                createParticle(mouseX, mouseY);
                lastMouseTime = now;
            }
            
            if (isDragging && draggedFish) {
                const waterRect = waterBody.getBoundingClientRect();
                const x = (e.clientX - waterRect.left) / waterRect.width * 100;
                const y = (e.clientY - waterRect.top) / waterRect.height * 100;
                
                draggedFish.x = Math.max(3, Math.min(97, x));
                draggedFish.y = Math.max(8, Math.min(92, y));
                
                const vx = (draggedFish.x - lastDragX) * 80;
                const vy = (draggedFish.y - lastDragY) * 80;
                
                draggedFish.vx = vx * 0.25;
                draggedFish.vy = vy * 0.25;
                draggedFish.targetVx = vx * 0.15;
                draggedFish.targetVy = vy * 0.15;
                
                lastDragX = draggedFish.x;
                lastDragY = draggedFish.y;
            }
        });
        
        tank.addEventListener('mouseleave', () => {
            isMouseInTank = false;
            cursorGlow.style.opacity = '0';
            isDragging = false;
            draggedFish = null;
        });
        
        tank.addEventListener('mouseenter', () => {
            cursorGlow.style.opacity = '1';
        });
        
        // 点击投喂
        tank.addEventListener('click', (e) => {
            if (e.button !== 0) return;
            
            const rect = waterBody.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width * 100;
            const y = (e.clientY - rect.top) / rect.height * 100;
            
            const food = document.createElement('div');
            food.className = 'food-pellet';
            
            food.style.left = x + '%';
            food.style.top = Math.max(8, y - 4) + '%';
            foodLayer.appendChild(food);
            
            const foodObj = {
                x: x,
                y: Math.max(8, y - 4),
                element: food,
                vy: 0.11 + Math.random() * 0.08
            };
            foods.push(foodObj);
            
            const sink = () => {
                if (!document.body.contains(food)) return;
                
                foodObj.y += foodObj.vy;
                food.style.top = foodObj.y + '%';
                
                foodObj.x += Math.sin(foodObj.y * 0.07) * 0.06;
                food.style.left = foodObj.x + '%';
                
                if (foodObj.y < 88) {
                    requestAnimationFrame(sink);
                } else {
                    food.style.opacity = '0.15';
                    setTimeout(() => {
                        if (document.body.contains(food)) {
                            food.remove();
                            foods = foods.filter(f => f !== foodObj);
                        }
                    }, 6000);
                }
            };
            requestAnimationFrame(sink);
            
            const ripple = document.createElement('div');
            ripple.className = 'water-ripple';
            ripple.style.left = x + '%';
            ripple.style.top = y + '%';
            waterBody.appendChild(ripple);
            setTimeout(() => ripple.remove(), 2000);
        });
        
        // 右键拖拽
        tank.addEventListener('mousedown', (e) => {
            if (e.button !== 2) return;
            e.preventDefault();
            
            const rect = waterBody.getBoundingClientRect();
            const clickX = (e.clientX - rect.left) / rect.width * 100;
            const clickY = (e.clientY - rect.top) / rect.height * 100;
            
            for (let i = fishes.length - 1; i >= 0; i--) {
                const fish = fishes[i];
                const dx = Math.abs(fish.x - clickX);
                const dy = Math.abs(fish.y - clickY);
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if (distance < 7) {
                    draggedFish = fish;
                    isDragging = true;
                    draggedFish.element.style.filter = 'drop-shadow(0 4px 8px rgba(0,0,0,0.08)) brightness(1.1)';
                    break;
                }
            }
        });
        
        tank.addEventListener('mouseup', (e) => {
            if (isDragging && draggedFish) {
                draggedFish.element.style.filter = 'drop-shadow(0 4px 8px rgba(0,0,0,0.08))';
                draggedFish = null;
                isDragging = false;
            }
        });
        
        tank.addEventListener('contextmenu', (e) => e.preventDefault());
        
        function createParticle(x, y) {
            const particle = document.createElement('div');
            particle.className = 'cursor-particle';
            particle.style.left = x + 'px';
            particle.style.top = y + 'px';
            waterBody.appendChild(particle);
            setTimeout(() => particle.remove(), 1000);
        }
        
        // 投喂功能
        function feedFish() {
            const feedCount = 3 + Math.floor(Math.random() * 3);
            const spreadWidth = 40 + Math.random() * 25;
            
            for (let i = 0; i < feedCount; i++) {
                setTimeout(() => {
                    const food = document.createElement('div');
                    food.className = 'food-pellet';
                    
                    const centerX = 50;
                    const startX = Math.max(12, Math.min(88, centerX + (Math.random() - 0.5) * spreadWidth));
                    food.style.left = startX + '%';
                    food.style.top = (8 + Math.random() * 3) + '%';
                    foodLayer.appendChild(food);
                    
                    const foodObj = {
                        x: startX,
                        y: 8 + Math.random() * 3,
                        element: food,
                        vy: 0.11 + Math.random() * 0.11
                    };
                    foods.push(foodObj);
                    
                    const sink = () => {
                        if (!document.body.contains(food)) return;
                        
                        foodObj.y += foodObj.vy;
                        food.style.top = foodObj.y + '%';
                        
                        foodObj.x += Math.sin(foodObj.y * (0.06 + Math.random() * 0.025)) * (0.05 + Math.random() * 0.03);
                        food.style.left = foodObj.x + '%';
                        
                        if (foodObj.y < 87 + Math.random() * 3) {
                            requestAnimationFrame(sink);
                        } else {
                            food.style.opacity = (0.11 + Math.random() * 0.08).toString();
                            setTimeout(() => {
                                if (document.body.contains(food)) {
                                    food.remove();
                                    foods = foods.filter(f => f !== foodObj);
                                }
                            }, 2500 + Math.random() * 1100);
                        }
                    };
                    requestAnimationFrame(sink);
                }, i * (40 + Math.random() * 60));
            }
        }
        
        function createBubble(x, y) {
            const bubble = document.createElement('div');
            bubble.className = 'bubble';
            const size = 4 + Math.random() * 10;
            bubble.style.width = size + 'px';
            bubble.style.height = size + 'px';
            bubble.style.left = (x || (10 + Math.random() * 80)) + '%';
            bubble.style.bottom = y ? (100 - y + Math.random() * 2) + '%' : (4 + Math.random() * 15) + '%';
            bubble.style.animationDuration = (3.5 + Math.random() * 4) + 's';
            bubble.style.animationDelay = (Math.random() * 0.4) + 's';
            bubbleLayer.appendChild(bubble);
            
            setTimeout(() => {
                if (document.body.contains(bubble)) {
                    bubble.remove();
                }
            }, 7500 + Math.random() * 800);
        }
        
        function addFish() {
            const maxFishCount = 10 + Math.floor(Math.random() * 4);
            if (fishes.length < maxFishCount) {
                fishes.push(new Fish());
            }
        }
        
        function scatterFish() {
            fishes.forEach(fish => fish.scatter());
            
            const rippleCount = 2 + Math.floor(Math.random() * 2);
            for(let i = 0; i < rippleCount; i++) {
                setTimeout(() => {
                    const ripple = document.createElement('div');
                    ripple.className = 'water-ripple';
                    ripple.style.left = (18 + Math.random() * 64) + '%';
                    ripple.style.top = (25 + Math.random() * 50) + '%';
                    waterBody.appendChild(ripple);
                    setTimeout(() => ripple.remove(), 2000);
                }, i * (50 + Math.random() * 60));
            }
        }
        
        // 初始化
        function init() {
            const initialFishCount = 5 + Math.floor(Math.random() * 3);
            for(let i = 0; i < initialFishCount; i++) {
                setTimeout(() => fishes.push(new Fish()), i * (200 + Math.random() * 200));
            }
            
            setInterval(() => createBubble(), 1600 + Math.random() * 1200);
            
            function animate() {
                fishes.forEach(fish => fish.update());
                updateCatEyes();
                requestAnimationFrame(animate);
            }
            requestAnimationFrame(animate);
        }
        
        init();
    </script>
</body>
</html>